# lib/tasks/init.rake
#
# frozen_string_literal: true

require 'openssl'
require 'securerandom'
require 'base64'

# HKDF helper — intentionally self-contained so this task works without
# booting the application (no Redis, no config needed).
module OTSInit
  SALT = 'onetimesecret-v1'

  DERIVED_KEYS = {
    'SESSION_SECRET' => { info: 'session', length: 64 },
    'HMAC_SECRET' => { info: 'hmac', length: 32 },
    'ARGON2_SECRET' => { info: 'argon2-pepper', length: 32 },
    'FEDERATION_HMAC_SECRET' => { info: 'federation', length: 32 },
    'VERIFIABLE_ID_HMAC_SECRET' => { info: 'verifiable-id', length: 32 },
  }.freeze

  def self.hkdf_hex(secret, info:, length:)
    raw = OpenSSL::KDF.hkdf(
      secret,
      salt: SALT,
      info: info,
      length: length,
      hash: 'SHA256',
    )
    raw.unpack1('H*')
  end

  def self.read_env(path)
    return {} unless File.exist?(path)

    pairs = {}
    File.readlines(path, chomp: true).each do |line|
      next if line.strip.empty? || line.start_with?('#')

      key, value = line.split('=', 2)
      next unless key && value

      pairs[key.strip] = value.strip.gsub(/\A["']|["']\z/, '')
    end
    pairs
  end

  def self.write_env(path, existing_lines, updates)
    updated_keys = Set.new
    output       = existing_lines.map do |line|
      stripped = line.strip
      next line if stripped.empty?

      # Check for commented-out derived key placeholders (e.g. #SESSION_SECRET=)
      # but skip block markers (#-----BEGIN/END DERIVED SECRETS-----)
      if stripped.start_with?('#') && !stripped.start_with?('#-')
        commented_content = stripped.sub(/\A#\s*/, '')
        key,              = commented_content.split('=', 2)
        key               = key&.strip
        if key && updates.key?(key)
          updated_keys << key
          next "#{key}=#{updates[key]}"
        end
        next line
      end

      key, = stripped.split('=', 2)
      key  = key&.strip
      if key && updates.key?(key)
        updated_keys << key
        "#{key}=#{updates[key]}"
      else
        line
      end
    end

    (updates.keys - updated_keys.to_a).each do |key|
      output << "#{key}=#{updates[key]}"
    end

    File.write(path, output.join("\n") + "\n")
  end
end

namespace :ots do
  desc 'Generate SECRET and derive child keys into .env (idempotent)'
  task :init do
    derive   = %w[1 true].include?(ENV.fetch('DERIVE', nil))
    force    = %w[1 true].include?(ENV.fetch('FORCE', nil))
    env_path = ENV['ENV_FILE'] || File.join(Dir.pwd, '.env')

    unless File.exist?(env_path)
      example = env_path.sub(/\.env\z/, '.env.example')
      if File.exist?(example)
        require 'fileutils'
        FileUtils.cp(example, env_path)
        puts "Copied #{example} → #{env_path}"
      else
        File.write(env_path, "# Generated by rake ots:init\n")
        puts "Created #{env_path}"
      end
    end

    existing       = OTSInit.read_env(env_path)
    existing_lines = File.readlines(env_path, chomp: true)

    secret     = existing['SECRET']
    has_secret = secret && !secret.empty? && secret != 'CHANGEME'

    if derive
      abort "ERROR: DERIVE=1 requires SECRET to be set in #{env_path}" unless has_secret
      puts "Reading existing SECRET from #{env_path}"
    elsif has_secret && !force
      puts "SECRET already set in #{env_path} (use FORCE=1 to regenerate)"
      puts 'Deriving child keys from existing SECRET.'
      derive = true
    else
      secret = SecureRandom.hex(64)
      puts 'Generated new SECRET (128 hex chars, 64 bytes entropy)'
    end

    updates           = {}
    updates['SECRET'] = secret unless derive

    OTSInit::DERIVED_KEYS.each do |env_var, config|
      value            = OTSInit.hkdf_hex(secret, info: config[:info], length: config[:length])
      updates[env_var] = value
      puts "  #{env_var} ← HKDF(SECRET, info=#{config[:info].inspect}, len=#{config[:length]})"
    end

    OTSInit.write_env(env_path, existing_lines, updates)

    puts
    puts "Written to #{env_path}"
    puts
    puts 'IMPORTANT: Back up SECRET — it is the single root from which'
    puts 'all other secrets are derived. If SECRET is lost, encrypted'
    puts 'data (stored secrets, sessions) cannot be recovered.'
  end
end
