# lib/tasks/init.rake
#
# frozen_string_literal: true

require 'securerandom'
require_relative '../onetime/key_derivation'

# Env file helpers for secret initialization.
# Delegates HKDF derivation to Onetime::KeyDerivation (single source of truth).
module OTSInit
  # Independent secrets (ADR-008 Category 2): generated with SecureRandom,
  # NOT derived from SECRET. Must be backed up individually.
  INDEPENDENT_SECRETS      = %w[AUTH_SECRET ARGON2_SECRET].freeze
  # 32 bytes = 256 bits of entropy for independent secrets
  INDEPENDENT_SECRET_BYTES = 32

  def self.read_env(path)
    return {} unless File.exist?(path)

    pairs = {}
    File.readlines(path, chomp: true).each do |line|
      next if line.strip.empty? || line.start_with?('#')

      key, value = line.split('=', 2)
      next unless key && value

      pairs[key.strip] = value.strip.gsub(/\A["']|["']\z/, '')
    end
    pairs
  end

  def self.write_env(path, existing_lines, updates)
    updated_keys = Set.new
    output       = existing_lines.map do |line|
      stripped = line.strip
      next line if stripped.empty?

      # Check for commented-out derived key placeholders (e.g. #SESSION_SECRET=)
      # but skip block markers (#-----BEGIN/END DERIVED SECRETS-----)
      if stripped.start_with?('#') && !stripped.start_with?('#-')
        commented_content = stripped.sub(/\A#\s*/, '')
        key,              = commented_content.split('=', 2)
        key               = key&.strip
        if key && updates.key?(key)
          updated_keys << key
          next "#{key}=#{updates[key]}"
        end
        next line
      end

      key, = stripped.split('=', 2)
      key  = key&.strip
      if key && updates.key?(key)
        updated_keys << key
        "#{key}=#{updates[key]}"
      else
        line
      end
    end

    (updates.keys - updated_keys.to_a).each do |key|
      output << "#{key}=#{updates[key]}"
    end

    # NOTE: CRLF line endings are normalized to LF here. readlines(chomp: true)
    # strips both \n and \r\n, and we rejoin with "\n". This is intentional —
    # .env files should use LF — but be aware if round-tripping matters.
    File.write(path, output.join("\n") + "\n")
  end
end

namespace :ots do
  namespace :env do
    desc 'Copy .env.example → .env if .env does not exist (idempotent)'
    task :setup do
      env_path = ENV['ENV_FILE'] || File.join(Dir.pwd, '.env')

      if File.exist?(env_path)
        puts "#{env_path} already exists"
      else
        example = env_path.sub(/\.env\z/, '.env.example')
        if File.exist?(example)
          require 'fileutils'
          FileUtils.cp(example, env_path)
          puts "Copied #{example} → #{env_path}"
        else
          File.write(env_path, "# Generated by rake ots:env:setup\n")
          puts "Created #{env_path}"
        end
      end
    end
  end

  desc <<~DESC.strip
    Generate SECRET and derive child keys into .env (idempotent).
    Env vars: ENV_FILE=path (default: .env), DERIVE=1 (re-derive child keys only), FORCE=1 (regenerate SECRET)
  DESC
  task secrets: 'ots:env:setup' do
    derive   = %w[1 true].include?(ENV.fetch('DERIVE', nil))
    force    = %w[1 true].include?(ENV.fetch('FORCE', nil))
    env_path = ENV['ENV_FILE'] || File.join(Dir.pwd, '.env')

    existing       = OTSInit.read_env(env_path)
    existing_lines = File.readlines(env_path, chomp: true)

    secret     = existing['SECRET']
    has_secret = secret && !secret.empty? && secret != 'CHANGEME'

    if derive
      abort "ERROR: DERIVE=1 requires SECRET to be set in #{env_path}" unless has_secret
      puts "Reading existing SECRET from #{env_path}"
    elsif has_secret && !force
      puts "SECRET already set in #{env_path} (use FORCE=1 to regenerate)"
      puts 'Deriving child keys from existing SECRET.'
      derive = true
    else
      secret = SecureRandom.hex(64)
      puts 'Generated new SECRET (128 hex chars, 64 bytes entropy)'
    end

    updates           = {}
    updates['SECRET'] = secret unless derive

    # Derived secrets (ADR-008 Category 1): deterministic HKDF from SECRET.
    Onetime::KeyDerivation::PURPOSES.each do |purpose, config|
      next unless config[:env_var] # skip runtime-only purposes (e.g. familia_enc)

      value                     = Onetime::KeyDerivation.derive_hex(secret, purpose)
      updates[config[:env_var]] = value
      puts "  #{config[:env_var]} ← HKDF(SECRET, info=#{config[:info].inspect}, len=#{config[:length]})"
    end

    # Independent secrets (ADR-008 Category 2): random, NOT derived from SECRET.
    OTSInit::INDEPENDENT_SECRETS.each do |env_var|
      if existing[env_var] && !existing[env_var].empty? && existing[env_var] != 'CHANGEME'
        puts "  #{env_var} already set (keeping existing value)"
      else
        updates[env_var] = SecureRandom.hex(INDEPENDENT_SECRET_BYTES)
        puts "  #{env_var} ← SecureRandom.hex(32) [independent]"
      end
    end

    # Federation secret (ADR-008 Category 3): shared across instances.
    # Never generated here — must be distributed manually or via passforge.
    federation = existing['FEDERATION_SECRET']
    if federation && !federation.empty? && federation != 'CHANGEME'
      puts '  FEDERATION_SECRET already set (keeping existing value)'
    else
      require 'passforge/wordlist'
      require 'passforge/passphrase'
      suggested = PassForge::Passphrase.generate(words: 5, separator: '-', capitalize: false)

      puts
      puts '  FEDERATION_SECRET not set.'
      puts '  Suggested value (generated via passforge):'
      puts
      puts "    #{suggested}"
      puts
      puts '  This must be identical across all instances in a federation group.'
      puts '  (Not written to .env — must be set manually on every instance before starting)'
      puts '  Copy this value to FEDERATION_SECRET in .env on every instance,'
      puts '  or generate your own with:'
      puts '    bundle exec ruby -e "require \'passforge/wordlist\'; require \'passforge/passphrase\'; puts PassForge::Passphrase.generate(words: 5, separator: \'-\', capitalize: false)"'
      puts
    end

    OTSInit.write_env(env_path, existing_lines, updates)

    puts
    puts "Written to #{env_path}"
    puts
    puts 'IMPORTANT: Back up SECRET and the independent secrets (AUTH_SECRET,'
    puts 'ARGON2_SECRET). SECRET is the root for derived keys; independent'
    puts 'secrets cannot be regenerated if lost.'
  end
end
