# lib/onetime/models/organization.rb
#
# frozen_string_literal: true

require 'rack/utils'

module Onetime
  # Organization Model
  #
  # Opaque Identifier Pattern (OWASP IDOR Prevention):
  # Uses dual-ID system to prevent enumeration attacks in URLs/APIs.
  #
  # Primary Keys & Identifiers:
  #   - objid - Primary key (UUID), internal
  #   - extid - External identifier (e.g., on%<id>s), user-facing
  #
  # Foreign Keys:
  #   - org_id (underscore) - Foreign key field, stores the objid value
  #   - All FK relationships use objid values for indexing
  #
  # API Layer:
  #   - Public URLs/APIs should use extid for user-facing references
  #   - Use find_by_extid(extid) to convert extid → object
  #   - Internally, relationships always use objid
  #
  # Logging:
  #   - Use extid. Don't log internal IDs.
  #
  # Easy way to remember: if you can see a UUID, it's an internal ID. If
  # you can't, it's an external ID.
  #
  class Organization < Familia::Horreum
    include Familia::Features::Autoloader

    using Familia::Refinements::TimeLiterals

    # Use 'organization' prefix to match config_name for Familia v2 participation lookups
    prefix :organization

    feature :safe_dump_fields

    feature :relationships
    feature :object_identifier
    feature :external_identifier, format: 'on%<id>s'
    feature :required_fields
    feature :with_organization_billing
    feature :with_entitlements

    # Migration features - REMOVE after v1→v2 migration complete
    feature :with_migration_fields
    feature :organization_migration_fields

    identifier_field :objid

    # Unique index for contact email (prevents duplicates, enables fast lookups)
    unique_index :contact_email, :contact_email_index

    # Core fields
    field :display_name
    field :description
    field :owner_id       # custid of organization owner (internal objid of Customer)
    field :contact_email  # Primary billing/contact email
    field :is_default     # Boolean: true for auto-created workspace (prevents deletion)

    hashkey :urls
    jsonkey :caboose  # Migration metadata and payment link info

    # Track pending invitation objids for efficient querying
    # Unlike members/teams, this is NOT auto-generated - we manage it manually
    sorted_set :pending_invitations

    # CRITICAL: DO NOT manually define sorted_set :members, :teams, :domains, or :receipts
    # These are AUTO-GENERATED by Familia v2 participates_in declarations:
    # - Customer.participates_in :Organization, :members
    # - CustomDomain.participates_in :Organization, :domains
    # - Receipt.participates_in :Organization, :receipts
    # Manual declarations will CLOBBER the auto-generated relationship functionality!

    def init
      @planid ||= 'free'  # Default to free plan
      nil
    end

    def org_id
      objid
    end

    # Owner management
    def owner
      Onetime::Customer.load(owner_id) if owner_id
    end

    def owner?(customer)
      customer && customer.custid == owner_id
    end

    # Member management - Familia v2 auto-generated methods
    # The members sorted_set is auto-generated by Customer.participates_in Organization, :members
    # Call add_members_instance(customer) and remove_members_instance(customer) directly

    def member?(customer)
      return false unless customer

      # members is auto-generated sorted_set
      members.member?(customer.objid)
    end

    def member_count
      # members is auto-generated sorted_set
      members.size
    end

    def list_members
      # Bulk loading with auto-generated members collection
      # compact filters stale references (IDs in set but record deleted/not migrated)
      Customer.load_multi(members.to_a).compact
    end

    # Invitation management
    # pending_invitations stores OrganizationMembership objids

    def pending_invitation_count
      pending_invitations.size
    end

    def list_pending_invitations
      # Bulk loading with manually-managed pending_invitations collection
      # compact filters stale references (IDs in set but record deleted/not migrated)
      OrganizationMembership.load_multi(pending_invitations.to_a).compact
    end

    # Domain management - Familia v2 auto-generated methods wrapper
    # The domains sorted_set is auto-generated by CustomDomain.participates_in Organization, :domains
    # Auto-generated: org.domains (SortedSet)
    # Auto-generated: org.add_domains_instance(domain) / org.remove_domains_instance(domain)

    def add_domain(domain)
      # Prevent domains from belonging to multiple organizations
      existing_org = domain.organization_instances.first
      if existing_org && existing_org.objid != org_id
        raise Onetime::Problem, "Domain #{domain.display_domain} already belongs to organization #{existing_org.display_name}"
      end

      domain.add_to_organization_domains(self, Familia.now.to_f)
    end

    def remove_domain(domain)
      domain.remove_from_organization_domains(self)
    end

    def list_domains
      return [] if domains.empty?

      # Bulk loading with auto-generated domains collection
      # compact filters stale references (IDs in set but record deleted/not migrated)
      CustomDomain.load_multi(domains.to_a).compact
    end

    def domain_count
      # domains is auto-generated sorted_set
      domains.size
    end

    # Authorization helpers
    def can_modify?(current_user)
      owner?(current_user)
    end

    def can_delete?(current_user)
      # Default workspaces cannot be deleted (would break user's account)
      return false if is_default

      # Otherwise, only owners can delete
      owner?(current_user)
    end

    # Destroy organization with validation
    def destroy!
      # Prevent deletion if domains exist
      if domain_count > 0
        raise Onetime::Problem, 'Cannot delete organization with domains. Remove all domains first.'
      end

      # Remove all member participations
      # Use .compact to handle already-destroyed members (stale objids in set)
      list_members.compact.each do |member|
        remove_members_instance(member)
      end

      # Call parent destroy
      super
    end

    class << self
      def create!(display_name, owner_customer, contact_email = nil, **)
        raise Onetime::Problem, 'Owner required' if owner_customer.nil?

        display_name = display_name.to_s.strip
        raise Onetime::Problem, 'Display name required' if display_name.empty?

        contact_email = contact_email.to_s.strip
        # contact_email is optional - can be set later for billing
        if !contact_email.empty? && contact_email_exists?(contact_email)
          raise Onetime::Problem, 'Organization exists for that email address'
        end

        org = new(
          display_name: display_name,
          owner_id: owner_customer.custid,
          contact_email: contact_email.empty? ? nil : contact_email,
          **,
        )
        org.save

        # Add owner as first member with owner role using Familia v2 auto-generated bidirectional method
        org.add_members_instance(owner_customer, through_attrs: { role: 'owner' })

        OT.ld "[Organization.create!] org: extid.objid}, owner: #{owner_customer.custid}"

        org
      end

      def count
        instances.count # e.g. zcard dbkey
      end

      def contact_email_exists?(email)
        # Use unique_index auto-generated finder for O(1) lookup
        !find_by_contact_email(email).nil?
      end
    end
  end
end
