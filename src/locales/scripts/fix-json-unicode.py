"""
Corrects and decodes JSON files containing malformed Unicode escape sequences.

Raison d'Ãªtre:
This script addresses a specific issue where JSON files contain Unicode characters
represented as 'uXXXX' (e.g., 'u015f') instead of the standard JSON escape
sequence '\\uXXXX' (e.g., '\\u015f'). This non-standard format prevents
standard JSON parsers (like Python's json.loads or jq) from correctly
interpreting the file content, leading to errors or incorrect character rendering.

Such malformed sequences were observed in translations generated by certain
tools (e.g., early versions or specific configurations of Google Gemini models
as of April 2025), necessitating a pre-processing step to fix the escapes
before the JSON can be properly parsed and utilized.

The script reads the input file as raw text, uses regular expressions to
find and replace the incorrect 'uXXXX' sequences with the correct '\\uXXXX'
format, parses the corrected text into a Python object, and then writes
the object back to a new JSON file using standard UTF-8 encoding, ensuring
that Unicode characters are represented correctly and not re-escaped as ASCII.

Usage:
    python decode_json.py <input_file_path> <output_file_path>

Arguments:
    input_file_path:  Path to the source JSON file with malformed escapes.
    output_file_path: Path where the corrected and properly encoded JSON
                      will be written.
"""
import json
import sys
import io
import re # Import the regular expression module

if len(sys.argv) != 3:
    print("Usage: python decode_json.py <input_file> <output_file>")
    sys.exit(1)

infile_path = sys.argv[1]
outfile_path = sys.argv[2]

try:
    # 1. Read the entire file content as a raw string
    print(f"Reading raw content from: {infile_path}")
    with io.open(infile_path, 'r', encoding='utf-8') as f_in:
        raw_content = f_in.read()

    # 2. Use regex to find 'u' followed by 4 hex digits (not preceded by a backslash)
    #    and replace with the standard JSON escape sequence '\uXXXX'.
    #    Regex breakdown:
    #    (?<!\\) - Negative lookbehind: ensures the 'u' is NOT preceded by a backslash.
    #    u       - Matches the literal character 'u'.
    #    ([0-9a-fA-F]{4}) - Matches exactly 4 hexadecimal characters and captures them (group 1).
    print("Correcting malformed Unicode escape sequences (uXXXX -> \\uXXXX)...")
    corrected_content = re.sub(r'(?<!\\)u([0-9a-fA-F]{4})', r'\\u\1', raw_content)

    # 3. Parse the corrected string containing standard JSON escapes
    print("Parsing corrected content as JSON...")
    data = json.loads(corrected_content)

    # 4. Write the parsed data to the output file using UTF-8 encoding.
    #    ensure_ascii=False prevents Python from escaping non-ASCII characters.
    #    indent=2 provides readable, pretty-printed JSON output.
    print(f"Writing decoded JSON to: {outfile_path}")
    with io.open(outfile_path, 'w', encoding='utf-8') as f_out:
        json.dump(data, f_out, ensure_ascii=False, indent=2)

    print(f"Successfully corrected and decoded '{infile_path}' to '{outfile_path}'")

except FileNotFoundError:
    print(f"Error: Input file not found at '{infile_path}'")
    sys.exit(1)
except json.JSONDecodeError as json_err:
    print(f"JSON Decode Error after correction: {json_err}")
    print(f"Error occurred near line {json_err.lineno}, column {json_err.colno}")
    print("The file might still have structural JSON issues even after fixing escapes.")
    # Optionally, write the intermediate corrected_content to a temp file for debugging
    # with open("debug_corrected_content.txt", "w", encoding="utf-8") as debug_f:
    #     debug_f.write(corrected_content)
    # print("Intermediate corrected content saved to debug_corrected_content.txt")
    sys.exit(1)
except Exception as e:
    print(f"An unexpected error occurred: {e}")
    sys.exit(1)
