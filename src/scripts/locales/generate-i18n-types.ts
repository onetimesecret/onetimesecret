#!/usr/bin/env tsx

// src/scripts/locales/generate-i18n-types.ts

/**
 * I18n Type Generator Script
 *
 * Generates TypeScript types from locale JSON files to enable compile-time
 * validation of i18n keys. This ensures that typos like t('web.COMMO.typo')
 * cause TypeScript errors instead of runtime fallback behavior.
 *
 * Usage:
 *   pnpm run i18n:generate-types
 *   # or directly:
 *   tsx src/scripts/locales/generate-i18n-types.ts
 *
 * Output:
 *   src/types/generated/i18n-keys.d.ts
 *
 * The generated types augment vue-i18n's DefineLocaleMessage interface
 * to provide strict key validation for the t() function.
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const LOCALES_DIR = path.resolve(__dirname, '../../locales/en');
const OUTPUT_FILE = path.resolve(__dirname, '../../types/generated/i18n-keys.d.ts');

interface NestedObject {
  [key: string]: string | NestedObject;
}

/**
 * Recursively extracts all dot-notation key paths from a nested object.
 * Stops at string values (leaf nodes) - does not include intermediate paths.
 *
 * @param obj - The nested object to extract keys from
 * @param prefix - Current path prefix for recursion
 * @returns Array of dot-notation key paths
 */
function extractKeyPaths(obj: NestedObject, prefix = ''): string[] {
  const keys: string[] = [];

  for (const key of Object.keys(obj)) {
    const value = obj[key];
    const fullPath = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      keys.push(fullPath);
    } else if (typeof value === 'object' && value !== null) {
      keys.push(...extractKeyPaths(value as NestedObject, fullPath));
    }
  }

  return keys;
}

/**
 * Reads all JSON files from the English locale directory and merges them.
 * Uses the same merge logic as src/i18n.ts to ensure consistency.
 */
function loadAllLocaleFiles(): NestedObject {
  const merged: NestedObject = {};
  const files = fs.readdirSync(LOCALES_DIR).filter(f => f.endsWith('.json'));

  console.log(`Found ${files.length} locale files in ${LOCALES_DIR}`);

  for (const file of files) {
    const filePath = path.join(LOCALES_DIR, file);
    const content = JSON.parse(fs.readFileSync(filePath, 'utf-8'));

    // Deep merge - mirrors the logic in src/i18n.ts
    deepMerge(merged, content);
    console.log(`  Merged: ${file}`);
  }

  return merged;
}

/**
 * Deep merge helper - matches src/i18n.ts implementation
 */
function deepMerge(target: NestedObject, source: NestedObject): NestedObject {
  for (const key of Object.keys(source)) {
    const value = source[key];
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      if (!target[key] || typeof target[key] !== 'object') {
        target[key] = {};
      }
      deepMerge(target[key] as NestedObject, value as NestedObject);
    } else {
      target[key] = value;
    }
  }
  return target;
}

/**
 * Builds a TypeScript nested interface from the locale structure.
 * This preserves the full structure for DefineLocaleMessage augmentation.
 */
function buildNestedInterface(obj: NestedObject, indent = 2): string {
  const lines: string[] = [];
  const spaces = ' '.repeat(indent);

  for (const key of Object.keys(obj).sort()) {
    const value = obj[key];
    // Escape keys that need quoting (contain special chars)
    const safeKey = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? key : `'${key}'`;

    if (typeof value === 'string') {
      lines.push(`${spaces}${safeKey}: string;`);
    } else if (typeof value === 'object' && value !== null) {
      lines.push(`${spaces}${safeKey}: {`);
      lines.push(buildNestedInterface(value as NestedObject, indent + 2));
      lines.push(`${spaces}};`);
    }
  }

  return lines.join('\n');
}

/**
 * Generates the type declaration file content.
 */
function generateTypeDeclaration(localeData: NestedObject, allKeys: string[]): string {
  // Sort keys for consistent output
  const sortedKeys = [...allKeys].sort();

  // Generate the union type of all valid keys
  const keyUnionType = sortedKeys.map(k => `  | '${k}'`).join('\n');

  // Generate nested interface structure
  const nestedStructure = buildNestedInterface(localeData);

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: pnpm run i18n:generate-types
// Source: src/locales/en/*.json
// Generated at: ${new Date().toISOString()}

/**
 * Type-safe i18n keys for vue-i18n
 *
 * This file provides compile-time validation for translation keys.
 * Invalid keys like t('web.COMMO.typo') will cause TypeScript errors.
 *
 * Regenerate after modifying locale files:
 *   pnpm run i18n:generate-types
 */

/**
 * Union type of all valid i18n key paths.
 * Total: ${sortedKeys.length} keys
 */
export type I18nKey =
${keyUnionType};

/**
 * Nested structure matching the locale JSON files.
 * Used for DefineLocaleMessage augmentation.
 */
export interface LocaleMessageSchema {
${nestedStructure}
}

/**
 * Vue I18n type augmentation for strict key validation.
 *
 * This makes t() and $t() type-safe:
 * - t('web.COMMON.loading') - OK
 * - t('web.COMMO.typo') - TypeScript error
 */
declare module 'vue-i18n' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  export interface DefineLocaleMessage extends LocaleMessageSchema {}
}
`;
}

/**
 * Ensures the output directory exists.
 */
function ensureOutputDir(): void {
  const dir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`Created directory: ${dir}`);
  }
}

/**
 * Main execution
 */
function main(): void {
  console.log('I18n Type Generator');
  console.log('='.repeat(60));

  try {
    // Load and merge all locale files
    const localeData = loadAllLocaleFiles();

    // Extract all key paths
    const allKeys = extractKeyPaths(localeData);
    console.log(`\nExtracted ${allKeys.length} translation keys`);

    // Generate type declaration
    const typeContent = generateTypeDeclaration(localeData, allKeys);

    // Write output file
    ensureOutputDir();
    fs.writeFileSync(OUTPUT_FILE, typeContent, 'utf-8');

    console.log(`\nGenerated: ${OUTPUT_FILE}`);
    console.log('='.repeat(60));
    console.log('Type generation complete.');
    console.log('\nTo verify, run: pnpm run type-check');
  } catch (error) {
    console.error('Error generating types:', error);
    process.exit(1);
  }
}

main();
