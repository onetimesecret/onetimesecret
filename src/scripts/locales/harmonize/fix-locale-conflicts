#!/bin/bash

# Production script to fix structural conflicts in locale files
# Resolves type mismatches between base and target locale files
#
# Usage: ./fix-locale-conflicts [-q] [-f] [-v] [-c] LOCALE
# -q: quiet mode (suppress output)
# -f: filename only output
# -v: verbose output
# -c: copy values from base file for missing keys
#
# LOCALE should be a locale code (e.g., "es", "fr") corresponding to a directory
# in ../../../locales/ containing locale JSON files
#
# Exit: 0 if fix succeeds, 1 if fails

QUIET=${QUIET:-0}
FILENAME_ONLY=${FILENAME_ONLY:-0}
VERBOSE=${VERBOSE:-0}
COPY_VALUES=${COPY_VALUES:-0}
BASELOCALE=${BASELOCALE:-"en"}
BASEDIR=${BASEDIR:-"../../../locales/${BASELOCALE}"}

while getopts ":qfvc" opt; do
  case $opt in
    q) QUIET=1 ;;
    f) FILENAME_ONLY=1 ;;
    v) VERBOSE=1 ;;
    c) COPY_VALUES=1 ;;
    \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
  esac
done
shift $((OPTIND -1))

LOCALE="$1"
[ -z "$LOCALE" ] && echo "Usage: $0 [-q] [-f] [-v] [-c] LOCALE" >&2 && exit 1

LOCALEDIR="../../../locales/${LOCALE}"
[ ! -d "$LOCALEDIR" ] && echo "Locale directory not found: $LOCALEDIR" >&2 && exit 1
[ ! -d "$BASEDIR" ] && echo "Base locale directory not found: $BASEDIR" >&2 && exit 1

# Skip if fixing the base locale against itself
if [ "$LOCALE" = "$BASELOCALE" ]; then
  [ $QUIET -eq 0 ] && echo "Skipping self-fix for $LOCALE"
  exit 0
fi

jq_fix_script='
# Strategy: Use base structure as template, preserve target translations where compatible
# When types conflict, prioritize base structure and relocate conflicting target content

def preserve_and_fix($base; $target):
  # Extract conflicting content that we want to preserve
  ($target.web.colonel.dashboard // {}) as $dashboard_obj |
  ($target.web.colonel.welcome // {}) as $welcome_obj |

  # Apply base structure with target translations where compatible
  def apply_structure($struct; $trans; $path):
    if ($struct | type) == "object" then
      if ($trans | type) == "object" then
        # Both objects - recurse through structure
        $struct | with_entries(
          .key as $k |
          .value as $v |
          .value = apply_structure($v; ($trans[$k] // null); $path + [$k])
        )
      else
        # Target is primitive but base expects object - use base structure with empty values
        $struct | with_entries(.value =
          if (.value | type) == "object" then
            apply_structure(.value; {}; $path + [.key])
          else
            if '$COPY_VALUES' == "1" then .value else "" end
          end
        )
      end
    else
      # Base is primitive
      if ($trans | type) == ($struct | type) then
        # Compatible types - use target value if not empty
        if $trans != null and $trans != "" then $trans else (if '$COPY_VALUES' == "1" then $struct else "" end) end
      elif $trans == null then
        # Target missing - use base or empty
        if '$COPY_VALUES' == "1" then $struct else "" end
      else
        # Type mismatch - use base value
        $struct
      end
    end;

  # Apply the structure transformation
  apply_structure($base; $target; []) |

  # Relocate preserved object content to appropriate locations
  if ($dashboard_obj | type) == "object" and ($dashboard_obj | keys | length) > 0 then
    # Merge dashboard object content into web.dashboard
    .web.dashboard = ((.web.dashboard // {}) + $dashboard_obj)
  else . end |

  if ($welcome_obj | type) == "object" and ($welcome_obj | keys | length) > 0 then
    # Store welcome object content in a new location
    .web.colonel.welcome_details = $welcome_obj
  else . end;

# Main execution
preserve_and_fix($base[0]; $target[0])
'

# Process each JSON file in the locale directory
ERROR_COUNT=0
SUCCESS_COUNT=0

for LOCALE_FILE in "$LOCALEDIR"/*.json; do
  [ ! -f "$LOCALE_FILE" ] && continue

  FILENAME=$(basename "$LOCALE_FILE")
  BASEFILE="$BASEDIR/$FILENAME"

  # Skip if corresponding base file doesn't exist
  if [ ! -f "$BASEFILE" ]; then
    [ $VERBOSE -eq 1 ] && echo "Skipping $FILENAME (no corresponding base file)"
    continue
  fi

  OUTPUT="${LOCALE_FILE%.json}.conflict-fixed.json"

  [ $VERBOSE -eq 1 ] && echo "Fixing conflicts in $FILENAME..."

  if jq -n --slurpfile base "$BASEFILE" --slurpfile target "$LOCALE_FILE" "$jq_fix_script" > "$OUTPUT"; then
    # Validate generated JSON
    if ! jq empty "$OUTPUT" 2>/dev/null; then
      [ $FILENAME_ONLY -eq 1 ] && echo "$LOCALE_FILE"
      [ $QUIET -eq 0 ] && echo "Generated invalid JSON for $LOCALE_FILE"
      rm -f "$OUTPUT"
      ERROR_COUNT=$((ERROR_COUNT + 1))
      continue
    fi

    # Replace original with fixed version
    mv "$OUTPUT" "$LOCALE_FILE"

    [ $VERBOSE -eq 1 ] && echo "âœ“ Fixed conflicts in $FILENAME"
    SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
  else
    [ $FILENAME_ONLY -eq 1 ] && echo "$LOCALE_FILE"
    [ $QUIET -eq 0 ] && echo "Failed to fix conflicts in $FILENAME"
    rm -f "$OUTPUT" 2>/dev/null
    ERROR_COUNT=$((ERROR_COUNT + 1))
  fi
done

[ $QUIET -eq 0 ] && [ $VERBOSE -eq 0 ] && echo "Fixed conflicts in $SUCCESS_COUNT file(s) for locale '$LOCALE'"

if [ $ERROR_COUNT -gt 0 ]; then
  [ $QUIET -eq 0 ] && echo "Failed to fix $ERROR_COUNT file(s)" >&2
  exit 1
fi

exit 0
