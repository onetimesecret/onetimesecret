#!/bin/bash

# Repairs i18n locale files to match base en/ key structure
# Preserves existing translations while moving/adding keys. To put it another
# way, the `keys` move but the existing values are preserved.
#
# Usage: ./harmonize-locale-file [-q] [-f] [-v] [-c] LOCALE
# -q: quiet mode
# -f: filename only output
# -v: verbose output
# -c: copy values from base file
#
# LOCALE should be a locale code (e.g., "es", "fr") corresponding to a directory
# in ../../../locales/ containing locale JSON files
#
# Exit: 0 if repair succeeds, 1 if fails

QUIET=${QUIET:-0}
FILENAME_ONLY=${FILENAME_ONLY:-0}
VERBOSE=${VERBOSE:-0}
COPY_VALUES=${COPY_VALUES:-0}
BASELOCALE=${BASELOCALE:-"en"}
BASEDIR=${BASEDIR:-"../../../locales/${BASELOCALE}"}

while getopts ":qfvc" opt; do
  case $opt in
    q) QUIET=1 ;;
    f) FILENAME_ONLY=1 ;;
    v) VERBOSE=1 ;;
    c) COPY_VALUES=1 ;;
    \?) echo "Invalid option: -$OPTARG" >&2; exit 1 ;;
  esac
done
shift $((OPTIND -1))

LOCALE="$1"
[ -z "$LOCALE" ] && echo "Usage: $0 [-q] [-f] [-v] [-c] LOCALE" >&2 && exit 1

LOCALEDIR="../../../locales/${LOCALE}"
[ ! -d "$LOCALEDIR" ] && echo "Locale directory not found: $LOCALEDIR" >&2 && exit 1
[ ! -d "$BASEDIR" ] && echo "Base locale directory not found: $BASEDIR" >&2 && exit 1

# `find_value` searches for a key's value anywhere in the object structure
#  `walk`:
#    - First checks for direct matches
#    - Then searches for the value anywhere in the target object
#    - Finally falls back to empty string or base value
#
# This handles all cases of key restructuring:
# - Moving keys from top-level to nested
# - Moving keys from nested to top-level
# - Preserving all existing translations regardless of location
# - Adding missing keys with empty strings (or base values with -c)

jq_script='
def find_value($key; $obj):
  if $obj == null then
    null
  elif ($obj | type) == "object" then
    if $obj | has($key) then
      $obj[$key]
    else
      reduce ($obj | to_entries[]) as $entry (null;
        if . != null then .
        else $entry.value | find_value($key; .)
        end
      )
    end
  else
    null
  end;

def empty_structure($v):
  if $v | type == "object" then
    $v | map_values(empty_structure(.))
  else
    ""
  end;

def walk($base; $target_root):
  . as $target |
  if type == "object" then
    $base | with_entries(
      .key as $k |
      .value as $v |
      {
        key: $k,
        value: (
          if ($target | has($k)) and ($target[$k] != null) then
            $target[$k] | walk($v; $target_root)
          else
            find_value($k; $target_root) as $existing_value |
            if $existing_value != null then
              $existing_value
            else
              if '$COPY_VALUES' == 1 then
                $v
              else
                empty_structure($v)
              end
            end
          end
        )
      }
    )
  else
    if . == null then (if '$COPY_VALUES' == 1 then $base else "" end) else . end
  end;

$target[0] | walk($base[0]; $target[0])
'

# Process each JSON file in the locale directory
ERROR_COUNT=0
SUCCESS_COUNT=0

for LOCALE_FILE in "$LOCALEDIR"/*.json; do
  [ ! -f "$LOCALE_FILE" ] && continue

  FILENAME=$(basename "$LOCALE_FILE")
  BASEFILE="$BASEDIR/$FILENAME"

  # Skip if corresponding base file doesn't exist
  if [ ! -f "$BASEFILE" ]; then
    [ $VERBOSE -eq 1 ] && echo "Skipping $FILENAME (no corresponding base file)"
    continue
  fi

  OUTPUT="${LOCALE_FILE%.json}.transformed.json"

  if ! DEBUG="$DEBUG" jq -n --slurpfile base "$BASEFILE" --slurpfile target "$LOCALE_FILE" "$jq_script" > "$OUTPUT"; then
    [ $FILENAME_ONLY -eq 1 ] && echo "$LOCALE_FILE"
    [ $VERBOSE -eq 1 ] && echo "Failed repairing $LOCALE_FILE"
    ERROR_COUNT=$((ERROR_COUNT + 1))
    continue
  fi

  mv "$OUTPUT" "$LOCALE_FILE"
  [ $VERBOSE -eq 1 ] && echo "Repaired $LOCALE_FILE"
  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
done

[ $QUIET -eq 0 ] && [ $VERBOSE -eq 0 ] && echo "Harmonized $SUCCESS_COUNT file(s) for locale '$LOCALE'"

if [ $ERROR_COUNT -gt 0 ]; then
  [ $QUIET -eq 0 ] && echo "Failed to harmonize $ERROR_COUNT file(s)" >&2
  exit 1
fi

exit 0
