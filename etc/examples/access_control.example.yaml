# etc/access_control.yaml
#
# IP-Based Access Control Configuration
#
# This middleware signals access mode based on client IP matching against
# an allowlist. It NEVER blocks requests - instead, it sets a downstream
# header that application logic can consume to enforce policy.
#
# ## How It Works
#
# 1. Reverse proxy/load balancer sets trigger header with shared secret
# 2. Middleware activates only when trigger header + secret match
# 3. Client IP extracted from X-Forwarded-For (or REMOTE_ADDR)
# 4. IP matched against allowed_cidrs
# 5. Mode header set: 'normal' (allowed) or 'protected' (denied)
# 6. Application code checks mode header to enforce policy
#
# ## Example Infrastructure Setup
#
# Caddy reverse proxy configuration:
#
# ```
# example.com {
#     @homepage path /
#     handle @homepage {
#         header_up O-Access-Control-Trigger "your-shared-secret"
#         reverse_proxy localhost:3000
#     }
#     reverse_proxy localhost:3000
# }
# ```
#
# Nginx configuration:
#
# ```
# location / {
#     proxy_set_header O-Access-Control-Trigger "your-shared-secret";
#     proxy_pass http://localhost:3000;
# }
# ```
#
# ## Security Notes
#
# - Trigger secret MUST be shared only with trusted infrastructure
# - Do NOT set trigger header in application code
# - Do NOT expose trigger secret in logs or error messages
# - Client cannot bypass by setting trigger header (secret required)
# - Consider rotating trigger secret periodically
#
---
access_control:
  # Master toggle for IP-based access control
  #
  # When false, middleware is completely inactive (no header evaluation,
  # no mode header set, requests pass through untouched)
  #
  enabled: <%= ENV['ACCESS_CONTROL_ENABLED'] == 'true' %>

  # Trigger Configuration
  #
  # Upstream infrastructure (reverse proxy, load balancer) signals when
  # to activate IP checking by sending a specific header with a shared secret.
  #
  # This prevents:
  # - Client spoofing (they don't know the secret)
  # - Unnecessary IP checks on routes that don't need access control
  # - Performance overhead when access control isn't needed
  #
  trigger:
    # Header name that reverse proxy will set
    # Standard practice: Use 'X-' prefix for custom headers
    #
    header: <%= ENV['ACCESS_CONTROL_TRIGGER_HEADER'] || 'O-Access-Control-Trigger' %>

    # Shared secret between infrastructure and application
    #
    # SECURITY CRITICAL:
    # - Must be strong, random value (32+ characters recommended)
    # - Must match exactly between proxy config and this setting
    # - Should be rotated periodically
    # - Keep out of version control (use environment variable)
    #
    # Generate with: openssl rand -base64 32
    #
    secret: <%= ENV['ACCESS_CONTROL_TRIGGER_SECRET'] %>

  # Trusted Proxy Depth
  #
  # ⚠️  CRITICAL SECURITY SETTING
  #
  # Number of trusted proxies in your infrastructure chain. This determines
  # how X-Forwarded-For header is interpreted to prevent IP spoofing.
  #
  # DEFAULT: 0 (X-Forwarded-For IGNORED, uses REMOTE_ADDR only)
  #
  # Only set > 0 when ALL these conditions are met:
  # 1. Application is behind a trusted reverse proxy
  # 2. Direct access to application is BLOCKED by firewall
  # 3. Proxy strips/overrides client-provided X-Forwarded-For
  #
  # Values:
  # - 0: Ignore X-Forwarded-For, use REMOTE_ADDR (SAFEST, DEFAULT)
  # - 1: Trust 1 proxy (use rightmost IP in X-Forwarded-For)
  # - 2: Trust 2 proxies (use 2nd rightmost IP)
  #
  # Example without firewall protection (VULNERABLE):
  #   curl -H "X-Forwarded-For: 10.0.0.1" http://app:3000/
  #   # Attacker spoofs internal IP, bypasses allowlist
  #
  # See security documentation for firewall configuration examples.
  #
  trusted_proxy_depth: <%= ENV['TRUSTED_PROXY_DEPTH'] || '0' %>

  # IP Allowlist
  #
  # CIDR blocks that should receive unprotected access. Requests from
  # these IPs will have mode header set to 'allow' value.
  #
  # Common private IP ranges (RFC 1918):
  # - 10.0.0.0/8        (10.0.0.0 - 10.255.255.255)
  # - 172.16.0.0/12     (172.16.0.0 - 172.31.255.255)
  # - 192.168.0.0/16    (192.168.0.0 - 192.168.255.255)
  #
  # IPv6 private ranges:
  # - fc00::/7          (Unique Local Addresses)
  # - fe80::/10         (Link-Local Addresses)
  #
  # Examples:
  # - '10.0.0.0/8'               # Entire 10.x network
  # - '192.168.1.0/24'           # Single subnet
  # - '203.0.113.5/32'           # Single IP address
  # - 'fc00::/7'                 # IPv6 ULA
  #
  # Set via ALLOWED_CIDRS environment variable (comma-separated)
  # Example: ALLOWED_CIDRS="10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
  #
  allowed_cidrs:
<% (ENV['ALLOWED_CIDRS'] || '10.0.0.0/8,172.16.0.0/12,192.168.0.0/16').split(',').map(&:strip).each do |cidr| %>
    - <%= cidr %>
<% end %>

  # Mode Signal Configuration
  #
  # Header and values that middleware sets for downstream application
  # consumption. Application code reads this header to determine what
  # access policy to enforce.
  #
  mode:
    # Header name set by middleware for application to read
    #
    # Application code example:
    # ```ruby
    # if req.env['HTTP_O_ACCESS_MODE'] == 'protected'
    #   # Show protected content
    # else
    #   # Show normal content
    # end
    # ```
    #
    header: <%= ENV['ACCESS_CONTROL_MODE_HEADER'] || 'O-Access-Mode' %>

    # Value set when client IP is in allowed_cidrs
    # Indicates IP-based access control is satisfied
    #
    allow: <%= ENV['ACCESS_MODE_ALLOW'] || 'normal' %>

    # Value set when client IP is NOT in allowed_cidrs
    # Indicates IP-based access control failed
    #
    deny: <%= ENV['ACCESS_MODE_DENY'] || 'protected' %>

# Environment Variable Reference
#
# Set these in your environment or .env file:
#
# # Enable access control
# export ACCESS_CONTROL_ENABLED=true
#
# # Trigger configuration (REQUIRED when enabled)
# export ACCESS_CONTROL_TRIGGER_HEADER="O-Access-Control-Trigger"
# export ACCESS_CONTROL_TRIGGER_SECRET="$(openssl rand -base64 32)"
#
# # Trusted proxy depth (IMPORTANT FOR SECURITY)
# export TRUSTED_PROXY_DEPTH=1  # Only if behind reverse proxy with firewall
#
# # IP allowlist (comma-separated CIDRs, no limit)
# # Single CIDR:
# export ALLOWED_CIDRS="10.0.0.0/8"
# # Multiple CIDRs:
# export ALLOWED_CIDRS="10.0.0.0/8,172.16.0.0/12,192.168.1.0/24"
# # With IPv6 and specific IPs:
# export ALLOWED_CIDRS="10.0.0.0/8,172.16.0.0/12,203.0.113.5/32,fc00::/7"
#
# # Mode signal customization (optional)
# export ACCESS_CONTROL_MODE_HEADER="O-Access-Mode"
# export ACCESS_MODE_ALLOW="normal"
# export ACCESS_MODE_DENY="protected"
#
# Firewall Configuration Examples
#
# ⚠️  CRITICAL: Block direct access to application when using trusted_proxy_depth > 0
#
# UFW (Ubuntu):
# ```bash
# # Allow only from reverse proxy
# sudo ufw allow from 10.0.1.100 to any port 3000 proto tcp
# sudo ufw deny 3000
# ```
#
# iptables:
# ```bash
# # Allow only from reverse proxy at 10.0.1.100
# iptables -A INPUT -p tcp -s 10.0.1.100 --dport 3000 -j ACCEPT
# iptables -A INPUT -p tcp --dport 3000 -j DROP
# ```
#
# Docker network isolation:
# ```yaml
# services:
#   app:
#     networks:
#       - internal  # Not exposed to internet
#   proxy:
#     networks:
#       - internal
#       - external
# networks:
#   internal:
#     internal: true
#   external:
# ```
