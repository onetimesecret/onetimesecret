#!/usr/bin/env ruby

base_path             = File.expand_path('..', __dir__)
$LOAD_PATH.unshift File.join(base_path, 'lib')
ENV['ONETIME_HOME'] ||= base_path.freeze

APPS_ROOT = File.join(base_path, 'apps').freeze
$LOAD_PATH.unshift(File.join(APPS_ROOT, 'api'))
$LOAD_PATH.unshift(File.join(APPS_ROOT, 'web'))

require 'onetime' # loads bundler/setup
require 'onetime/cli'
require 'rubygems'
require 'drydock'

# Command-line interface for bin/stella
class OT::CLI::Definition
  extend Drydock

  before do
    # Separate our content from the bootstrapping banner (only in interactive terminals)
    puts '' if $stdout.tty?
  end

  global :v, :verbose, 'Increase output' do
    @verbose ||= 0
    @verbose  += 1
  end

  global :D, :debug do
    OT.instance_variable_set(:@debug, true)
  end

  command :load_path, 'Lists the first 5 paths in the load path' do
    puts $LOAD_PATH[0...5]
  end

  option :B, :delay_boot, 'Bring up the console without initializing'
  about 'Ruby irb with Onetime preloaded'
  command :console do |obj|
    cmd = format('irb -I%s -ronetime/console', File.join(Onetime::HOME, 'lib'))
    OT.ld cmd

    # Set the boot env var for the console process
    ENV['DELAY_BOOT'] = obj.option.delay_boot.to_s
    Kernel.exec(cmd)

    # TODO: https://claude.ai/share/1ea04861-aec8-4872-bb5c-84bb87a16a9d
    # Then instead of exec, use:
    # require 'irb'
    # Create a custom workspace with your loaded environment
    # workspace = IRB::WorkSpace.new(binding)
    # irb = IRB::Irb.new #(workspace)

    # # Start the session
    # IRB.conf[:MAIN_CONTEXT] = irb.context
    # irb.eval_input

    # require 'onetime/console'
    # Your custom prompt and configuration is already set up above

    # Start IRB in the current context
    # IRB.start(__FILE__)
  end

  usage 'ots server [options]'
  about 'Start the web server (Puma or Thin)'
  option :s, :server, String, 'Server type: puma or thin (default: puma)'
  option :p, :port, Integer, 'Port to bind to (default: 7143)'
  option :e, :environment, String, 'Environment to run in (default: development)'
  option :t, :threads, String, 'Thread pool size for Puma (default: 2:4)'
  option :w, :workers, Integer, 'Number of workers for Puma (default: 0)'
  option :b, :bind, String, 'Bind address for Thin (default: 0.0.0.0)'
  command server: OT::ServerCommand

  usage 'ots version'
  command :version do
    puts format('Onetime %s', OT::VERSION.inspect)
  end
  alias_command :build, :version

  # In OT::CLI::Definition in bin/ots
  usage 'ots migrate MIGRATION_SCRIPT [--run]'
  about 'Run a migration script from the migrate/ directory'
  option :r, :run, 'Actually apply changes (default is dry run mode)'
  command migrate: OT::MigrateCommand

  usage 'ots migrate-redis-data [--run]'
  about 'Consolidate Redis data from multiple databases to database 0'
  about 'By default, runs in dry-run mode to preview changes'
  about 'Use --run to perform the actual consolidation'
  option :r, :run, 'Execute the consolidation (required for actual operation)'
  option :s, :show_commands, 'Generate redis-cli commands for manual execution'
  option :y, :yes, 'Auto-confirm consolidation (non-interactive mode)'
  option :b, :batch_size, Integer, 'Set batch size for consolidation (default: 100, max: 10000)'
  option :h, :help, 'Show detailed help message'
  command migrate_redis_data: OT::MigrateRedisDataCommand

  usage 'ots sync-auth-accounts [--run]'
  about 'Synchronize customer records from Redis to Auth SQL database'
  about 'Primary use case: switching from auth mode=basic to mode=advanced'
  about 'By default, runs in dry-run mode to preview changes'
  option :r, :run, 'Execute synchronization (required for actual operation)'
  option :h, :help, 'Show detailed help message'
  command sync_auth_accounts: OT::SyncAuthAccountsCommand

  usage 'ots customers'
  option :l, :list, 'List customer domains (by count)'
  option :c, :check, 'Show customer records where custid and email do not match (obscured)'
  command customers: OT::CustomersCommand

  usage 'ots domains'
  option :l, :list, 'List domains'
  command domains: OT::DomainsCommand

  usage 'ots change-email OLD_EMAIL NEW_EMAIL [REALM]'
  about 'Change customer email address and update all related records'
  about 'Usage: ots change-email OLD_EMAIL NEW_EMAIL [REALM]'
  about "  Change a customer's email address and update related records."
  about ''
  about '  Arguments:'
  about '    OLD_EMAIL    Current email address of the customer'
  about '    NEW_EMAIL    New email address to change to'
  about '    REALM        Optional: Geographic region (US/EU/CA/NZ), defaults to US'
  about ''
  about '  Example:'
  about '    ots change-email user@example.com new@example.com'
  about ''
  about '  Note: Custom domains associated with this customer will be'
  about '  automatically detected and updated.'
  about ''
  command change_email: OT::ChangeEmailCommand

  usage 'ots change-email-log [EMAIL] [--verbose] [--limit N]'
  about 'View history of email address changes'
  option :v, :verbose, 'Display full change reports'
  option :n, :limit, Integer, 'Limit number of reports to show (default: 10)'
  command change_email_log: OT::ChangeEmailCommand

  usage 'ots revalidate-domains'
  about 'Revalidate domain verification status. Optionally specify a domain and/or customer_id.'
  option :d, :domain, String, 'Domain to revalidate'
  option :c, :custid, String, 'Customer ID to revalidate'
  command revalidate_domains: OT::DomainsCommand

  usage 'ots session <subcommand>'
  about 'Session inspection and debugging tools'
  about 'Subcommands:'
  about '  inspect <session-id>       - Show detailed session information'
  about '  list [--limit N]           - List active sessions'
  about '  search <email-or-custid>   - Find sessions for a user'
  about '  delete <session-id>        - Delete a session'
  about '  clean                      - Remove expired sessions'
  option :l, :limit, Integer, 'Limit number of results'
  option :f, :force, 'Force operation without confirmation'
  command session: OT::SessionCommand

  usage 'ots totp <secret> [--verify CODE]'
  about 'Generate or verify TOTP codes for MFA testing'
  about 'Arguments:'
  about '  secret              - Base32-encoded TOTP secret'
  about 'Options:'
  about '  --verify CODE       - Verify a 6-digit code against the secret'
  about '  --compute-hmac      - Compute HMAC version of raw secret'
  about '  --raw SECRET        - Use with --compute-hmac to compute HMAC'
  about ''
  about 'Examples:'
  about '  ots totp JBSWY3DPEHPK3PXP'
  about '  ots totp JBSWY3DPEHPK3PXP --verify 123456'
  about '  ots totp --compute-hmac --raw omidgappklu267g756mo2l4q2pq5m4rz'
  option :v, :verify, String, 'Verify a TOTP code'
  option :c, :compute_hmac, 'Compute HMAC secret from raw secret'
  option :r, :raw, String, 'Raw secret for HMAC computation'
  command :totp do |obj, secret = nil|
    require 'onetime/utils/totp'

    # Get secret from first argument if not using --compute-hmac
    secret ||= obj.argv.shift unless obj.option.compute_hmac

    if obj.option.compute_hmac
      unless obj.option.raw
        puts "Error: --raw SECRET required when using --compute-hmac"
        exit 1
      end

      begin
        hmac_secret = Onetime::Utils::TOTP.compute_hmac(obj.option.raw)
        puts "Raw secret:  #{obj.option.raw}"
        puts "HMAC secret: #{hmac_secret}"
        puts ""
        puts "Use the HMAC secret in your authenticator app."
      rescue => e
        puts "Error: #{e.message}"
        exit 1
      end
    elsif obj.option.verify
      unless secret
        puts "Error: SECRET required"
        exit 1
      end

      result = Onetime::Utils::TOTP.verify(secret, obj.option.verify)
      puts "Secret:        #{result[:secret_sample]}"
      puts "Code:          #{result[:code]}"
      puts "Expected:      #{result[:expected_code]}"
      puts "Valid:         #{result[:valid] ? 'YES' : 'NO'}"
      puts "Match:         #{result[:match] ? 'YES' : 'NO'}"

      exit(result[:valid] ? 0 : 1)
    else
      unless secret
        puts "Error: SECRET required"
        puts "Usage: ots totp <secret>"
        exit 1
      end

      result = Onetime::Utils::TOTP.generate(secret)
      puts "Secret:        #{result[:secret_sample]}"
      puts "Issuer:        #{result[:issuer]}"
      puts ""
      puts "Current Code:  #{result[:current_code]}"
      puts "Previous Code: #{result[:previous_code]}"
      puts "Next Code:     #{result[:next_code]}"
      puts ""
      puts "Valid for:     #{result[:valid_for]} seconds"
      puts "Time:          #{Time.at(result[:current_time]).strftime('%Y-%m-%d %H:%M:%S %Z')}"
    end
  end

  # usage 'ots initializers [--dependencies]'
  # about 'Display boot-time initializers in order'
  # about 'Use global --verbose for full module names'
  # option :d, :dependencies, 'Show dependencies for each initializer'
  # command initializers: OT::InitializersCommand

  # usage 'ots validate'
  # usage 'ots validate [CONFIG_PATH]'
  # usage 'ots validate --basename mutable'
  # usage 'ots validate --full'
  # about 'Validate configuration file against JSON schema. Without'
  # about 'arguments, validates the static config file: etc/config.yaml'
  # about 'Use global -v for error details and -v -v for full error paths'
  # option :f, :full, 'Run validation checks and raise concerns'
  # option :show, 'Show validated configuration'
  # option :s, :schema, String, 'Path to custom JSON schema file'
  # option :n, :basename, String, 'Base name for validation (e.g. "config" in "config.yaml")'
  # command validate: OT::ValidateCommand

  # usage 'ots config'
  # about 'Parse, resolve, and render configuration'
  # about 'Use global --verbose for full configuration details'
  # option :t, :types, 'Show types for each configuration key'
  # command config: OT::ConfigCommand
end

begin
  Drydock.run! ARGV, STDIN
rescue RuntimeError => ex
  warn ex.message
rescue StandardError => ex
  puts ex.message
  puts ex.backtrace
  exit 1
end
