#!/usr/bin/env ruby
# frozen_string_literal: true

# bin/ots-init
#
# Generates SECRET and derives child keys, writing them to .env.
# Standalone — does not boot the application or need Redis.
#
# Usage:
#   bin/ots-init            # generate SECRET + derived keys (skips if SECRET exists)
#   bin/ots-init --derive   # read existing SECRET, write derived keys only
#   bin/ots-init --force    # regenerate SECRET even if it exists (DANGER)
#
# The only value an operator needs to back up is SECRET.
# All other secret-material env vars are deterministically derived from it.

require 'openssl'
require 'securerandom'
require 'base64'
require 'optparse'

SALT = 'onetimesecret-v1'

DERIVED_KEYS = {
  'SESSION_SECRET'        => { info: 'session',       length: 64 },
  'ARGON2_SECRET'         => { info: 'argon2-pepper', length: 32 },
  'FEDERATION_HMAC_SECRET'=> { info: 'federation',    length: 32 },
}.freeze

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def hkdf_hex(secret, info:, length:)
  raw = OpenSSL::KDF.hkdf(
    secret,
    salt: SALT,
    info: info,
    length: length,
    hash: 'SHA256'
  )
  raw.unpack1('H*')
end

def read_env(path)
  return {} unless File.exist?(path)

  lines = File.readlines(path, chomp: true)
  pairs = {}
  lines.each do |line|
    next if line.strip.empty? || line.start_with?('#')

    key, value = line.split('=', 2)
    next unless key && value

    # Strip surrounding quotes
    pairs[key.strip] = value.strip.gsub(/\A["']|["']\z/, '')
  end
  pairs
end

def write_env(path, existing_lines, updates)
  # Update in-place: replace lines that match updated keys, append new ones.
  updated_keys = Set.new
  output = existing_lines.map do |line|
    stripped = line.strip
    next line if stripped.empty? || stripped.start_with?('#')

    key, = stripped.split('=', 2)
    key = key&.strip
    if key && updates.key?(key)
      updated_keys << key
      "#{key}=#{updates[key]}"
    else
      line
    end
  end

  # Append any keys that weren't already in the file
  (updates.keys - updated_keys.to_a).each do |key|
    output << "#{key}=#{updates[key]}"
  end

  File.write(path, output.join("\n") + "\n")
end

# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: bin/ots-init [options]"

  opts.on('--derive', 'Read existing SECRET, write derived keys only') do
    options[:derive] = true
  end

  opts.on('--force', 'Regenerate SECRET even if it already exists') do
    options[:force] = true
  end

  opts.on('--env FILE', 'Path to .env file (default: .env)') do |f|
    options[:env_file] = f
  end

  opts.on('-h', '--help', 'Show this help') do
    puts opts
    exit
  end
end.parse!

env_path = options[:env_file] || File.join(Dir.pwd, '.env')

unless File.exist?(env_path)
  # If no .env, try to copy from .env.example
  example = env_path.sub(/\.env$/, '.env.example')
  if File.exist?(example)
    require 'fileutils'
    FileUtils.cp(example, env_path)
    puts "Copied #{example} → #{env_path}"
  else
    File.write(env_path, "# Generated by bin/ots-init\n")
    puts "Created #{env_path}"
  end
end

existing = read_env(env_path)
existing_lines = File.readlines(env_path, chomp: true)

secret = existing['SECRET']
has_secret = secret && !secret.empty? && secret != 'CHANGEME'

if options[:derive]
  unless has_secret
    warn "ERROR: --derive requires SECRET to be set in #{env_path}"
    exit 1
  end
  puts "Reading existing SECRET from #{env_path}"

elsif has_secret && !options[:force]
  puts "SECRET already set in #{env_path} (use --force to regenerate)"
  puts "Running in --derive mode to write derived keys."
  options[:derive] = true

else
  # Generate new SECRET
  secret = SecureRandom.hex(64) # 128 hex chars = 64 bytes entropy
  puts "Generated new SECRET (128 hex chars, 64 bytes entropy)"
end

# Derive child keys
updates = {}
updates['SECRET'] = secret unless options[:derive]

DERIVED_KEYS.each do |env_var, config|
  value = hkdf_hex(secret, info: config[:info], length: config[:length])
  updates[env_var] = value
  puts "  #{env_var} ← HKDF(SECRET, info=#{config[:info].inspect}, len=#{config[:length]})"
end

write_env(env_path, existing_lines, updates)

puts
puts "Written to #{env_path}"
puts
puts "IMPORTANT: Back up SECRET — it is the single root from which"
puts "all other secrets are derived. If SECRET is lost, encrypted"
puts "data (stored secrets, sessions) cannot be recovered."
