# migrations/2026-01-28/lib/destinations/redis_index_destination.rb
#
# frozen_string_literal: true

require 'redis'

module Migration
  module Destinations
    # Kiba destination for Redis index commands (ZADD, HSET, SADD, INCRBY).
    #
    # Executes index commands generated by transforms to rebuild
    # Redis indexes in the target database.
    #
    # Expected record format:
    # - command: Redis command (ZADD, HSET, SADD, INCRBY)
    # - key: Redis key name
    # - args: Array of arguments for the command
    #
    # Usage in Kiba job:
    #   destination RedisIndexDestination,
    #     valkey_url: 'redis://localhost:6379',
    #     db: 6,
    #     dry_run: false
    #
    class RedisIndexDestination
      VALID_COMMANDS = %w[ZADD HSET SADD INCRBY].freeze

      attr_reader :valkey_url, :db, :dry_run, :stats

      # @param valkey_url [String] Redis/Valkey connection URL
      # @param db [Integer] Target database number
      # @param dry_run [Boolean] If true, count commands without executing
      # @param stats [Hash] Optional stats hash for tracking progress
      #
      def initialize(valkey_url:, db:, dry_run: false, stats: nil)
        @valkey_url = valkey_url
        @db = db
        @dry_run = dry_run
        @stats = stats || { executed: 0, skipped: 0, errors: [] }
        @redis = nil
      end

      # Write (execute) a single index command.
      #
      # @param record [Hash] Record with command, key, args
      #
      def write(record)
        return if record.nil?

        command = record[:command]
        key = record[:key]
        args = record[:args]

        unless VALID_COMMANDS.include?(command)
          @stats[:skipped] += 1
          @stats[:errors] << { key: key, error: "Unknown command: #{command}" }
          return
        end

        unless key && args.is_a?(Array)
          @stats[:skipped] += 1
          @stats[:errors] << { key: key, error: 'Missing key or args' }
          return
        end

        if @dry_run
          @stats[:executed] += 1
          return
        end

        connect! unless @redis
        execute_command(command, key, args)
        @stats[:executed] += 1
      rescue Redis::CommandError => ex
        @stats[:skipped] += 1
        @stats[:errors] << { key: key, command: command, error: ex.message }
      end

      # Close the Redis connection.
      #
      def close
        @redis&.close
        @redis = nil
      end

      private

      def connect!
        # Strip any existing database number from the URL before appending the target DB
        base_url = @valkey_url.sub(%r{/\d+$}, '')
        @redis = Redis.new(url: "#{base_url}/#{@db}")
        @redis.ping # Verify connection
      rescue Redis::CannotConnectError => ex
        raise ArgumentError, "Failed to connect to Redis (DB #{@db}): #{ex.message}"
      end

      def execute_command(command, key, args)
        case command
        when 'ZADD'
          # args: [score, member] or [score, member, score, member, ...]
          @redis.zadd(key, *args)
        when 'HSET'
          # args: [field, value] or [field, value, field, value, ...]
          @redis.hset(key, *args)
        when 'SADD'
          # args: [member, ...]
          @redis.sadd(key, *args)
        when 'INCRBY'
          # args: [increment]
          @redis.incrby(key, args.first.to_i)
        end
      end
    end
  end
end
