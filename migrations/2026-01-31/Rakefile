# migrations/2026-01-31/Rakefile
#
# frozen_string_literal: true

# OTS v1 -> v2 Data Migration Tasks
#
# Run migrations in order with proper dependency checking.
#
# Usage:
#   cd migrations/2026-01-31
#   bundle exec rake -T                    # List tasks
#   bundle exec rake migrate:all           # Dry run all
#   bundle exec rake migrate:all RUN=1     # Execute all
#   bundle exec rake migrate:customer      # Dry run customer only
#   bundle exec rake migrate:customer RUN=1 # Execute customer

require 'fileutils'

MIGRATION_DIR = __dir__

# Migration phases in dependency order
MIGRATIONS = [
  { name: 'customer',      file: '01_customer_migration.rb',       desc: 'Customer key rename + field updates' },
  { name: 'organization',  file: '02_organization_generator.rb',   desc: 'Generate Organizations from Customers' },
  { name: 'custom_domain', file: '03_custom_domain_migration.rb',  desc: 'Link CustomDomains to Organizations' },
  { name: 'receipt',       file: '04_receipt_migration.rb',        desc: 'Migrate Metadata to Receipt format' },
  { name: 'secret',        file: '05_secret_migration.rb',         desc: 'Secret owner linkage' },
].freeze

def run_flag
  ENV['RUN'] == '1' ? '--run' : ''
end

def run_migration(file)
  path = File.join(MIGRATION_DIR, file)
  cmd = "bundle exec ruby #{path} #{run_flag}"
  puts "\n#{'=' * 60}"
  puts "Running: #{cmd}"
  puts '=' * 60
  system(cmd)
  $?.success?
end

namespace :migrate do
  desc 'Run all migrations in order (set RUN=1 to execute)'
  task :all do
    puts "OTS v1 -> v2 Data Migration"
    puts "Mode: #{ENV['RUN'] == '1' ? 'EXECUTE' : 'DRY RUN'}"
    puts

    failed = []
    MIGRATIONS.each do |m|
      puts "\n>>> Phase: #{m[:name]} - #{m[:desc]}"
      success = run_migration(m[:file])
      unless success
        failed << m[:name]
        puts "FAILED: #{m[:name]}"
        break # Stop on first failure
      end
    end

    puts "\n#{'=' * 60}"
    if failed.empty?
      puts "All migrations completed successfully"
    else
      puts "Migration failed at: #{failed.join(', ')}"
      exit 1
    end
  end

  desc 'Check migration status (no changes)'
  task :status do
    MIGRATIONS.each do |m|
      path = File.join(MIGRATION_DIR, m[:file])
      cmd = "bundle exec ruby #{path} --check"
      print "#{m[:name].ljust(15)}: "
      system(cmd)
      puts $?.success? ? "OK (not needed)" : "NEEDED"
    end
  end

  # Individual migration tasks
  MIGRATIONS.each do |m|
    desc "#{m[:desc]} (set RUN=1 to execute)"
    task m[:name].to_sym do
      success = run_migration(m[:file])
      exit 1 unless success
    end
  end

  desc 'Run customer migration'
  task :customer do
    run_migration('01_customer_migration.rb')
  end

  desc 'Generate organizations from customers'
  task organization: :customer do
    run_migration('02_organization_generator.rb')
  end

  desc 'Migrate custom domains to organizations'
  task custom_domain: :organization do
    run_migration('03_custom_domain_migration.rb')
  end

  desc 'Migrate metadata to receipt format'
  task receipt: :organization do
    run_migration('04_receipt_migration.rb')
  end

  desc 'Migrate secrets with owner linkage'
  task secret: :customer do
    run_migration('05_secret_migration.rb')
  end
end

# Validation tasks
namespace :validate do
  desc 'Validate customer migration'
  task :customer do
    require 'bundler/setup'
    require_relative '../../lib/onetime'
    OT.boot! :app

    puts "Validating Customer migration..."

    total = 0
    migrated = 0
    errors = []

    Onetime::Customer.instances.revrangeraw(0, -1).each do |id|
      cust = Onetime::Customer.load(id) rescue nil
      next unless cust
      next if cust.anonymous?

      total += 1

      if cust.v1_custid.to_s.present? && cust.objid.to_s.present?
        migrated += 1
      else
        errors << "#{cust.custid}: missing v1_custid or objid"
      end
    end

    puts "Total: #{total}, Migrated: #{migrated}, Errors: #{errors.size}"
    errors.first(10).each { |e| puts "  - #{e}" } if errors.any?
  end

  desc 'Validate organization generation'
  task :organization do
    require 'bundler/setup'
    require_relative '../../lib/onetime'
    OT.boot! :app

    puts "Validating Organization generation..."

    customers_without_org = 0
    orgs_without_owner = 0

    Onetime::Customer.instances.revrangeraw(0, -1).each do |id|
      cust = Onetime::Customer.load(id) rescue nil
      next unless cust
      next if cust.anonymous?

      orgs = cust.organization_instances.to_a rescue []
      customers_without_org += 1 if orgs.empty?
    end

    Onetime::Organization.instances.revrangeraw(0, -1).each do |id|
      org = Onetime::Organization.load(id) rescue nil
      next unless org

      orgs_without_owner += 1 if org.owner_id.to_s.empty?
    end

    puts "Customers without org: #{customers_without_org}"
    puts "Orgs without owner: #{orgs_without_owner}"
  end

  desc 'Run all validations'
  task all: %i[customer organization]
end

task default: 'migrate:status'
