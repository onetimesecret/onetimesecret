#!/usr/bin/env python3
"""
Scan and replace hardcoded "Onetime Secret" / "One-Time Secret" in locale
JSON source files with {product_name} interpolation for vue-i18n.

This enables self-hosted OTS instances to set their own product name via
config rather than being locked to "Onetime Secret".

Operates on: locales/content/<LOCALE>/*.json (flat-key source of truth)
Does NOT touch: generated/locales/ (regenerated by compile.py)

Usage:
    python interpolate-product-name.py                  # Dry-run report
    python interpolate-product-name.py --dry-run        # Same as above
    python interpolate-product-name.py --apply          # Apply changes
    python interpolate-product-name.py --locale en      # Single locale
    python interpolate-product-name.py --report-only    # Summary counts only

After applying, re-run compile.py to regenerate the nested runtime files:
    python build/compile.py --all --merged --output-dir ../../generated/locales
"""

import argparse
import hashlib
import json
import sys
from pathlib import Path
from typing import Any

# Path constants
SCRIPT_DIR = Path(__file__).parent.resolve()
LOCALES_DIR = SCRIPT_DIR.parent
CONTENT_DIR = LOCALES_DIR / "content"

# Patterns to replace, ordered by specificity (longest first)
# "One-Time Secret" is a variant spelling used in some keys
PRODUCT_NAME_PATTERNS = [
    ("One-Time Secret", "{product_name}"),
    ("Onetime Secret", "{product_name}"),
]

# Keys where the value is ONLY the product name (no surrounding text).
# These are typically used as literal brand labels, alt text, or titles.
# We still interpolate them -- the runtime default for {product_name}
# will be "Onetime Secret", so the output is identical unless overridden.
#
# If you want to SKIP pure-brand-name keys, add them to SKIP_KEYS instead.
SKIP_KEYS: set[str] = set()

# Keys where replacement would be incorrect or harmful.
# For example, a key that is an HTML attribute value referencing a
# specific domain, or a key that describes the project by its
# canonical name in a way that should not change for forks.
EXCLUDE_KEYS: set[str] = set()


def compute_sha256_prefix(text: str) -> str:
    """Compute the first 8 chars of SHA-256 hex digest, matching the
    convention used in the locale JSON files."""
    return hashlib.sha256(text.encode("utf-8")).hexdigest()[:8]


def replace_product_name(text: str) -> tuple[str, int]:
    """Replace hardcoded product name variants with {product_name}.

    Returns the new text and the number of replacements made.
    Skips text that already contains {product_name} to avoid
    double-interpolation.
    """
    if "{product_name}" in text:
        return text, 0

    total = 0
    new_text = text
    for pattern, replacement in PRODUCT_NAME_PATTERNS:
        # Case-sensitive replacement
        count = new_text.count(pattern)
        if count > 0:
            new_text = new_text.replace(pattern, replacement)
            total += count

    return new_text, total


def scan_file(
    file_path: Path, apply: bool = False
) -> list[dict[str, Any]]:
    """Scan a single JSON file for product name occurrences.

    Returns a list of change records. If apply=True, writes changes
    back to the file.
    """
    with open(file_path, encoding="utf-8") as f:
        data = json.load(f)

    changes: list[dict[str, Any]] = []
    modified = False

    for key, entry in data.items():
        if key.startswith("_"):
            continue
        if not isinstance(entry, dict) or "text" not in entry:
            continue
        if key in SKIP_KEYS or key in EXCLUDE_KEYS:
            continue

        text = entry["text"]
        if not isinstance(text, str):
            continue

        new_text, count = replace_product_name(text)
        if count > 0:
            change = {
                "file": str(file_path.relative_to(CONTENT_DIR)),
                "key": key,
                "old": text,
                "new": new_text,
                "replacements": count,
                "value_is_only_product_name": new_text.strip() in (
                    "{product_name}",
                    "{product_name}.",
                ),
            }
            changes.append(change)

            if apply:
                entry["text"] = new_text
                # Update sha256 to match the new text
                entry["sha256"] = compute_sha256_prefix(new_text)
                modified = True

    if apply and modified:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            f.write("\n")

    return changes


def scan_all(
    locale: str | None = None, apply: bool = False
) -> list[dict[str, Any]]:
    """Scan all locale content files (or a single locale) for product
    name occurrences."""
    all_changes: list[dict[str, Any]] = []

    if locale:
        locale_dirs = [CONTENT_DIR / locale]
        if not locale_dirs[0].is_dir():
            print(f"Error: locale directory not found: {locale_dirs[0]}", file=sys.stderr)
            sys.exit(1)
    else:
        locale_dirs = sorted(
            d for d in CONTENT_DIR.iterdir() if d.is_dir()
        )

    for locale_dir in locale_dirs:
        json_files = sorted(locale_dir.glob("*.json"))
        for json_file in json_files:
            changes = scan_file(json_file, apply=apply)
            all_changes.extend(changes)

    return all_changes


def print_report(changes: list[dict[str, Any]], report_only: bool = False) -> None:
    """Print a human-readable report of proposed or applied changes."""
    if not changes:
        print("No occurrences of hardcoded product name found.")
        return

    # Group by locale
    by_locale: dict[str, list[dict[str, Any]]] = {}
    for c in changes:
        locale = c["file"].split("/")[0]
        by_locale.setdefault(locale, []).append(c)

    # Group by file within en locale for the detailed sample
    by_file: dict[str, list[dict[str, Any]]] = {}
    for c in changes:
        by_file.setdefault(c["file"], []).append(c)

    # Summary
    total_replacements = sum(c["replacements"] for c in changes)
    pure_brand_count = sum(1 for c in changes if c["value_is_only_product_name"])
    mixed_count = len(changes) - pure_brand_count
    locales_affected = len(by_locale)
    files_affected = len(by_file)

    print("=" * 72)
    print("PRODUCT NAME INTERPOLATION REPORT")
    print("=" * 72)
    print()
    print(f"  Total keys with product name:  {len(changes)}")
    print(f"  Total string replacements:     {total_replacements}")
    print(f"  Locales affected:              {locales_affected}")
    print(f"  Files affected:                {files_affected}")
    print()
    print(f"  Pure brand-name values:        {pure_brand_count}")
    print(f"    (value is only '{{product_name}}' or '{{product_name}}.')")
    print(f"  Mixed/embedded values:         {mixed_count}")
    print(f"    (product name within longer text)")
    print()

    if report_only:
        print("Per-locale counts:")
        print("-" * 40)
        for locale in sorted(by_locale):
            locale_changes = by_locale[locale]
            print(f"  {locale:12s}  {len(locale_changes):4d} keys")
        print()
        return

    # Detailed report for EN locale (canonical reference)
    print("-" * 72)
    print("ENGLISH LOCALE (canonical keys)")
    print("-" * 72)
    en_changes = by_locale.get("en", [])
    if en_changes:
        for c in en_changes:
            print(f"\n  File: {c['file']}")
            print(f"  Key:  {c['key']}")
            print(f"  Old:  {c['old'][:120]}{'...' if len(c['old']) > 120 else ''}")
            print(f"  New:  {c['new'][:120]}{'...' if len(c['new']) > 120 else ''}")
            if c["value_is_only_product_name"]:
                print("  Note: Value is purely the product name")
    else:
        print("  (no changes in en locale)")

    # Per-locale summary
    print()
    print("-" * 72)
    print("PER-LOCALE SUMMARY")
    print("-" * 72)
    for locale in sorted(by_locale):
        locale_changes = by_locale[locale]
        pure = sum(1 for c in locale_changes if c["value_is_only_product_name"])
        mixed = len(locale_changes) - pure
        print(f"  {locale:12s}  {len(locale_changes):4d} keys  ({pure} pure, {mixed} mixed)")

    # Edge cases
    print()
    print("-" * 72)
    print("EDGE CASES AND CONCERNS")
    print("-" * 72)
    print()

    # Identify keys that exist in some locales but not en
    en_keys = {c["key"] for c in en_changes}
    non_en_only_keys: dict[str, set[str]] = {}
    for c in changes:
        locale = c["file"].split("/")[0]
        if locale != "en" and c["key"] not in en_keys:
            non_en_only_keys.setdefault(c["key"], set()).add(locale)

    if non_en_only_keys:
        print("  Keys with product name in non-en locales but NOT in en:")
        for key in sorted(non_en_only_keys):
            locales = sorted(non_en_only_keys[key])
            print(f"    {key}")
            print(f"      Locales: {', '.join(locales[:5])}{'...' if len(locales) > 5 else ''}")
        print()
        print("  These keys exist only in translated locales (en has")
        print("  different key names for the same content). The product")
        print("  name should still be interpolated in these translations.")
    else:
        print("  All affected keys are present in the en locale.")

    print()

    # Multiple replacements in single value
    multi = [c for c in changes if c["replacements"] > 1]
    if multi:
        print("  Keys with MULTIPLE product name occurrences in one value:")
        for c in multi:
            print(f"    {c['file']} :: {c['key']} ({c['replacements']}x)")
        print()

    # Existing {onetime-secret} interpolation (different param name)
    print("  NOTE: There is an existing {onetime-secret} interpolation")
    print("  in key 'web.meta.were_making_onetime_secret_available_in_multiple'.")
    print("  This script does NOT touch keys that already use interpolation.")
    print("  You may want to unify the param name to {product_name} manually.")
    print()


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Replace hardcoded product name with {product_name} interpolation"
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Apply changes to files (default is dry-run)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        default=True,
        help="Show changes without applying (default)",
    )
    parser.add_argument(
        "--locale",
        type=str,
        default=None,
        help="Process only this locale (e.g., 'en')",
    )
    parser.add_argument(
        "--report-only",
        action="store_true",
        help="Show only summary counts, no detailed changes",
    )

    args = parser.parse_args()

    if args.apply:
        mode = "APPLYING"
    else:
        mode = "DRY RUN"

    print(f"Mode: {mode}")
    print(f"Content dir: {CONTENT_DIR}")
    if args.locale:
        print(f"Locale: {args.locale}")
    print()

    changes = scan_all(locale=args.locale, apply=args.apply)
    print_report(changes, report_only=args.report_only)

    if args.apply and changes:
        print(f"Applied {len(changes)} changes across {len(set(c['file'] for c in changes))} files.")
        print()
        print("Next step: regenerate runtime locale files:")
        print("  cd locales/scripts && python build/compile.py --all --merged --output-dir ../../generated/locales")
    elif not args.apply and changes:
        print(f"To apply these changes, re-run with --apply")


if __name__ == "__main__":
    main()
