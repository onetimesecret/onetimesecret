# Translation Session Protocol

Branch: `feature/2319-workflow-historical`
Issue: #2319

## Philosophy

**"Excel first"** - We deliberately keep this workflow manual and conversational. No automation until the process is proven. The scripts are helpers, not a pipeline. Once we know exactly what works, we can build tooling.

## Core Concepts

### Task = One JSON Level
A task is all sibling keys sharing a parent path. For example, `web.COMMON.buttons.submit` and `web.COMMON.buttons.cancel` form one task under `web.COMMON.buttons`.

**Why:**
- Correlated strings translated together for consistency
- Natural batch size, self-limiting by design
- Forces good locale file organization (if a level is too large, restructure it)

### Glossary
Captures terminology decisions as we translate. When we decide "secret" → "sekreto" in Esperanto, that goes in the glossary so future sessions stay consistent.

### Export Guides
Locale-specific translation guidance in `locales/guides/for-translators/{locale}.md`. Read once per session to establish context. Mature locales (de, fr) have detailed guides; new locales (eo) build them as we go.

### Handoff
To continue work in a new session, generate a handoff document that preserves key decisions and context. Use `/handoff` or write one manually.

## Architecture

- **Task = one JSON level** - sibling keys grouped by parent path
- **SQLite is working state** - translations live in `locales/db/tasks.db` until synced
- **locales/content/ is source of truth** - `locales/content/{locale}/*.json` (flat format with `text` field)
- **generated/locales/ is app-consumable** - merged nested JSON for vue-i18n (auto-generated by frontend on startup)

## Starting a Translation Session

Begin a new Claude conversation with only this file for context:

```
@locales/TRANSLATION_PROTOCOL.md

Let's do a short translation session for [LOCALE]. Claim the next task and propose translations.
```

Replace `[LOCALE]` with the target locale code (e.g., `eo`, `fr_CA`, `de`).

## Fully Manual Session Workflow

### 0. Generate tasks (if not already done)
```bash
python locales/scripts/tasks/create.py eo
```
This populates the `translation_tasks` table required by `tasks/next.py`. Run once per locale, or re-run to refresh after English source changes.

Tasks are grouped by parent path (e.g., all keys under `web.COMMON.buttons`). This keeps work productive by batching related strings together rather than handling thousands of individual keys. Translators get more context since messages at the same level are usually related.

### 1. Check status
```bash
python locales/scripts/tasks/next.py eo --stats
```

### 2. Claim next task
```bash
python locales/scripts/tasks/next.py eo --claim
```
Outputs formatted table with Key, English, Esperanto columns.

### 3. Review proposed translations
Assistant proposes translations. Respond with:
- **A** - Accept (runs tasks/update.py)
- **S** - Skip (marks skipped, moves to next)
- **R** - Revisit (marks pending, moves to next)
- **Q** - Quit session

### 4. On accept, update task
```bash
python locales/scripts/tasks/update.py TASK_ID '{"key": "translation", ...}'
```

### 5. Record glossary decisions
```bash
python locales/scripts/store.py query "INSERT INTO glossary (locale, term, translation, notes) VALUES ('eo', 'secret', 'sekreto', 'core concept')"
```

### 6. End session - export to content
```bash
python locales/scripts/migrate/export.py eo
```
The frontend auto-generates `generated/locales/` on startup from `locales/content/`.

### 7. Commit
```bash
git add locales/content/eo/
git commit -m "[#2319] Add eo translations from session"
```

## Task Output Format

Title: `**Task 8** · _common.json · web.TITLES · 44 keys`

Table columns:
- Key (28 chars, right-aligned)
- English (60 chars, wrapped)
- Esperanto (60 chars, wrapped)

Sorted by English text length.

## Translation Notes Guidelines

- Include English source text with every proposal
- Compare to similar translations in other languages when relevant
- Note connotations (e.g., "secret" = personal vs confidential)
- Preserve `{placeholders}` exactly

## Key Files

```
locales/scripts/
  build/
    compile.py        # content -> generated (--all --merged)
    decompile.py      # src -> content (reverse sync)
  tasks/
    create.py         # Generate tasks grouped by parent path
    next.py           # --claim, --filter, --stats, --id
    update.py         # TASK_ID '{"key": "val"}'
    translate.py      # Claude-powered translation
  migrate/
    export.py         # SQLite -> locales/content/
    bootstrap.py      # Initialize locale content
    harmonize.py      # Harmonize locale files
  validate/
    json.py           # Validate JSON structure
    pr.py             # PR validation
    variables.py      # Audit variable usage
  keys.py             # Key utilities
  store.py            # migrate, hydrate, query

locales/db/
  schema.sql          # table definitions
  tasks.db            # SQLite database (not in git)
  *.sql               # SQL data files for hydrating tables. NOTE: tasks are not typically
                      # hydrated; they're generated into the database and processed until
                      # they are complete.

locales/content/{locale}/  # source of truth (flat JSON with text field)
generated/locales/         # app-consumable JSON (auto-generated by frontend)
```

## Database Tables

- `translation_tasks` - translation tasks grouped by JSON level
- `translation_issues` - QC findings requiring manual review
- `glossary` - terminology decisions per locale
- `session_log` - session records with verbatim notes
- `schema_migrations` - applied schema versions

## Quality Control Protocol

Periodic QC reviews catch issues that slip through initial translation: terminology drift, encoding errors, pluralization gaps, and cultural mismatches.

### Issue Types

| Type | Description |
|------|-------------|
| `terminology` | Inconsistent or incorrect term usage |
| `grammar` | Grammar/agreement errors |
| `encoding` | Encoding errors, garbled text |
| `missing` | Missing translation |
| `truncated` | Incomplete/cut-off translation |
| `pluralization` | Incorrect plural forms |
| `formality` | Formal/informal register inconsistency |
| `rtl` | RTL/bidirectional text issues |
| `placeholder` | Variable/placeholder problems |
| `tone` | Tone/voice inconsistency |
| `cultural` | Cultural adaptation issues |

### Severity Levels

- **critical** - Corrupted text, security-sensitive errors, broken functionality
- **high** - Incorrect terminology (passphrase/password), missing required forms
- **medium** - Inconsistencies, awkward phrasing, style violations
- **low** - Minor improvements, optional refinements

### Running a QC Review

1. **Spawn QC agents per locale** (parallel execution)
```
Spawn saas-translator agents to spot check translations for quality control.
One locale per agent. Report quality issues and glossary term suggestions.
```

2. **Query issues by priority**
```bash
python locales/scripts/store.py query \
  "SELECT locale, issue_type, severity, description
   FROM translation_issues
   WHERE status = 'open'
   ORDER BY severity, locale"
```

3. **Fix by priority batch** - Critical first, then high, then medium
```
Fix [LOCALE] translation issues:
- [list specific issues with file, key_path, and fix instructions]
```

4. **Update issue status after fixes**
```bash
python locales/scripts/store.py query \
  "UPDATE translation_issues
   SET status = 'resolved', resolved_at = datetime('now'), resolved_by = 'agent'
   WHERE id IN (1, 2, 3)"
```

### Parallel Agent Pattern

For efficiency, spawn one agent per locale with specific fix instructions:

| Agent | Locale | Issues |
|-------|--------|--------|
| Fix-Critical | tr, ja | Encoding errors, corrupted text |
| Fix-High | ar, ru, pt_BR | Pluralization, formality, terminology |
| Fix-Medium | de, es, nl, zh, pl | Consistency, style |

Monitor with single-poll pattern (see "Monitoring the process" section). Agents report back with before/after changes and JSON validation confirmation.

### Adding QC Findings to Database

```bash
python locales/scripts/store.py query \
  "INSERT INTO translation_issues
   (locale, file, key_path, issue_type, severity, description, detected_by)
   VALUES ('tr', 'secret-manage.json', 'web.private.key_name',
           'encoding', 'critical', 'Garbled text in translation', 'qc_agent')"
```

### Glossary Updates from QC

QC reviews often surface high-quality translation choices worth standardizing:

```bash
python locales/scripts/store.py query \
  "INSERT INTO glossary (locale, term, translation, context, notes)
   VALUES ('de', 'passphrase', 'Passphrase', 'security feature',
           'Keep as loanword - standard in German tech')"
```

## Monitoring the process

A single-poll pattern is recommended.

Avoid: each sleep N && command spawned as a background task creates an independent timer. When you spawn 10 of these while iterating, you get 10 delayed notifications that all arrive after you've moved on. It's a subtle footgun with background task orchestration - the "continuous loop" pattern only works in foreground terminals, not as background Claude tasks.

## Esperanto Status

Run `python locales/scripts/tasks/next.py eo --stats` to check current progress.
