#!/bin/bash

# Configuration split validation script
# Validates the config-mapping.yaml and tests the split-config script
#
# Usage: ./validate-config-split [-v] [-m MAPPING_FILE]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="$(dirname "$SCRIPT_DIR")"

# Defaults
MAPPING_FILE="${CONFIG_DIR}/config-mapping.yaml"
VERBOSE=0
TEMP_DIR=""

cleanup() {
    [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]] && rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Validate configuration split logic and mapping file.

OPTIONS:
    -m FILE     Mapping file to validate (default: ${MAPPING_FILE})
    -v          Verbose output
    -h          Show this help

VALIDATION CHECKS:
    1. Mapping file syntax validation
    2. Input file existence and syntax
    3. Split script execution
    4. Output file validation
    5. Key presence verification
    6. Data integrity check

EOF
}

while getopts "m:vh" opt; do
    case $opt in
        m) MAPPING_FILE="$OPTARG" ;;
        v) VERBOSE=1 ;;
        h) usage; exit 0 ;;
        \?) echo "Invalid option: -$OPTARG" >&2; usage >&2; exit 1 ;;
    esac
done

log() {
    echo "✓ $1"
}

error() {
    echo "✗ $1" >&2
}

verbose() {
    [[ $VERBOSE -eq 1 ]] && echo "  $1"
}

# Check dependencies
if ! command -v yq >/dev/null 2>&1; then
    error "yq is required but not installed"
    exit 1
fi

# Create temp directory
TEMP_DIR=$(mktemp -d)
verbose "Using temp directory: $TEMP_DIR"

# Validation 1: Mapping file syntax
echo "=== Validation 1: Mapping file syntax ==="
if [[ ! -f "$MAPPING_FILE" ]]; then
    error "Mapping file not found: $MAPPING_FILE"
    exit 1
fi

if ! yq eval '.' "$MAPPING_FILE" >/dev/null 2>&1; then
    error "Invalid YAML syntax in mapping file"
    exit 1
fi
log "Mapping file syntax is valid"

# Check mapping structure
if ! yq eval '.mappings.static' "$MAPPING_FILE" >/dev/null 2>&1; then
    error "Missing .mappings.static section in mapping file"
    exit 1
fi

if ! yq eval '.mappings.dynamic' "$MAPPING_FILE" >/dev/null 2>&1; then
    error "Missing .mappings.dynamic section in mapping file"
    exit 1
fi
log "Mapping file structure is valid"

# Count mappings
STATIC_COUNT=$(yq eval '.mappings.static | length' "$MAPPING_FILE")
DYNAMIC_COUNT=$(yq eval '.mappings.dynamic | length' "$MAPPING_FILE")
verbose "Static mappings: $STATIC_COUNT"
verbose "Dynamic mappings: $DYNAMIC_COUNT"

# Validation 2: Input file detection and syntax
echo "=== Validation 2: Input file validation ==="
INPUT_FILE=""
if [[ -f "${CONFIG_DIR}/config.yaml" ]]; then
    INPUT_FILE="${CONFIG_DIR}/config.yaml"
elif [[ -f "${CONFIG_DIR}/config.example.yaml" ]]; then
    INPUT_FILE="${CONFIG_DIR}/config.example.yaml"
else
    error "No input config file found (config.yaml or config.example.yaml)"
    exit 1
fi
log "Found input file: $INPUT_FILE"

if ! yq eval '.' "$INPUT_FILE" >/dev/null 2>&1; then
    error "Invalid YAML syntax in input file"
    exit 1
fi
log "Input file syntax is valid"

# Validation 3: Test split script execution
echo "=== Validation 3: Split script execution ==="
SPLIT_SCRIPT="${SCRIPT_DIR}/split-config"
if [[ ! -f "$SPLIT_SCRIPT" ]]; then
    error "Split script not found: $SPLIT_SCRIPT"
    exit 1
fi

if [[ ! -x "$SPLIT_SCRIPT" ]]; then
    error "Split script is not executable"
    exit 1
fi
log "Split script found and executable"

# Run split with temp outputs
TEMP_STATIC="${TEMP_DIR}/config.static.yaml"
TEMP_DYNAMIC="${TEMP_DIR}/config.dynamic.yaml"

if ! "$SPLIT_SCRIPT" -m "$MAPPING_FILE" -i "$INPUT_FILE" -s "$TEMP_STATIC" -d "$TEMP_DYNAMIC" -v; then
    error "Split script execution failed"
    exit 1
fi
log "Split script executed successfully"

# Validation 4: Output file validation
echo "=== Validation 4: Output file validation ==="
if [[ ! -f "$TEMP_STATIC" ]]; then
    error "Static output file not created"
    exit 1
fi

if [[ ! -f "$TEMP_DYNAMIC" ]]; then
    error "Dynamic output file not created"
    exit 1
fi
log "Output files created"

if ! yq eval '.' "$TEMP_STATIC" >/dev/null 2>&1; then
    error "Invalid YAML syntax in static output"
    exit 1
fi

if ! yq eval '.' "$TEMP_DYNAMIC" >/dev/null 2>&1; then
    error "Invalid YAML syntax in dynamic output"
    exit 1
fi
log "Output file syntax is valid"

# Validation 5: Key presence verification
echo "=== Validation 5: Key presence verification ==="
MISSING_KEYS=0

# Check static mappings
verbose "Checking static key mappings..."
while IFS=$'\t' read -r from_path to_path; do
    if [[ -n "$from_path" && -n "$to_path" ]]; then
        # Check if key exists in input
        if yq eval ".$from_path" "$INPUT_FILE" >/dev/null 2>&1; then
            INPUT_VALUE=$(yq eval ".$from_path" "$INPUT_FILE")
            if [[ "$INPUT_VALUE" != "null" ]]; then
                # Check if key exists in static output
                if yq eval ".$to_path" "$TEMP_STATIC" >/dev/null 2>&1; then
                    OUTPUT_VALUE=$(yq eval ".$to_path" "$TEMP_STATIC")
                    if [[ "$OUTPUT_VALUE" != "null" ]]; then
                        verbose "✓ Static key found: $to_path"
                    else
                        error "Static key missing in output: $to_path (from $from_path)"
                        MISSING_KEYS=$((MISSING_KEYS + 1))
                    fi
                else
                    error "Static key missing in output: $to_path (from $from_path)"
                    MISSING_KEYS=$((MISSING_KEYS + 1))
                fi
            else
                verbose "⚠ Static key is null in input (skipped): $from_path"
            fi
        else
            verbose "⚠ Static key not in input (skipped): $from_path"
        fi
    fi
done < <(yq eval '.mappings.static[] | .from + "\t" + .to' "$MAPPING_FILE")

# Check dynamic mappings
verbose "Checking dynamic key mappings..."
while IFS=$'\t' read -r from_path to_path; do
    if [[ -n "$from_path" && -n "$to_path" ]]; then
        # Check if key exists in input
        if yq eval ".$from_path" "$INPUT_FILE" >/dev/null 2>&1; then
            INPUT_VALUE=$(yq eval ".$from_path" "$INPUT_FILE")
            if [[ "$INPUT_VALUE" != "null" ]]; then
                # Check if key exists in dynamic output
                if yq eval ".$to_path" "$TEMP_DYNAMIC" >/dev/null 2>&1; then
                    OUTPUT_VALUE=$(yq eval ".$to_path" "$TEMP_DYNAMIC")
                    if [[ "$OUTPUT_VALUE" != "null" ]]; then
                        verbose "✓ Dynamic key found: $to_path"
                    else
                        error "Dynamic key missing in output: $to_path (from $from_path)"
                        MISSING_KEYS=$((MISSING_KEYS + 1))
                    fi
                else
                    error "Dynamic key missing in output: $to_path (from $from_path)"
                    MISSING_KEYS=$((MISSING_KEYS + 1))
                fi
            else
                verbose "⚠ Dynamic key is null in input (skipped): $from_path"
            fi
        else
            verbose "⚠ Dynamic key not in input (skipped): $from_path"
        fi
    fi
done < <(yq eval '.mappings.dynamic[] | .from + "\t" + .to' "$MAPPING_FILE")

if [[ $MISSING_KEYS -eq 0 ]]; then
    log "All mapped keys found in outputs"
else
    error "$MISSING_KEYS mapped keys missing from outputs"
fi

# Validation 6: Data integrity check
echo "=== Validation 6: Data integrity check ==="
INTEGRITY_ERRORS=0

# Sample a few key values and verify they match
verbose "Checking data integrity for sample keys..."

# Check static values
SAMPLE_STATIC_KEYS=(
    "site.host:site.host"
    "redis.uri:redis.uri"
)

for key_pair in "${SAMPLE_STATIC_KEYS[@]}"; do
    IFS=':' read -r from_key to_key <<< "$key_pair"

    if yq eval ".$from_key" "$INPUT_FILE" >/dev/null 2>&1; then
        INPUT_VALUE=$(yq eval ".$from_key" "$INPUT_FILE" 2>/dev/null || echo "null")
        OUTPUT_VALUE=$(yq eval ".$to_key" "$TEMP_STATIC" 2>/dev/null || echo "null")

        if [[ "$INPUT_VALUE" != "$OUTPUT_VALUE" ]]; then
            error "Value mismatch for $from_key: '$INPUT_VALUE' != '$OUTPUT_VALUE'"
            INTEGRITY_ERRORS=$((INTEGRITY_ERRORS + 1))
        else
            verbose "✓ Value match for $from_key"
        fi
    fi
done

# Check dynamic values
SAMPLE_DYNAMIC_KEYS=(
    "site.interface.ui.enabled:ui.enabled"
    "features.incoming.enabled:features.incoming_enabled"
)

for key_pair in "${SAMPLE_DYNAMIC_KEYS[@]}"; do
    IFS=':' read -r from_key to_key <<< "$key_pair"

    if yq eval ".$from_key" "$INPUT_FILE" >/dev/null 2>&1; then
        INPUT_VALUE=$(yq eval ".$from_key" "$INPUT_FILE" 2>/dev/null || echo "null")
        OUTPUT_VALUE=$(yq eval ".$to_key" "$TEMP_DYNAMIC" 2>/dev/null || echo "null")

        if [[ "$INPUT_VALUE" != "$OUTPUT_VALUE" ]]; then
            error "Value mismatch for $from_key: '$INPUT_VALUE' != '$OUTPUT_VALUE'"
            INTEGRITY_ERRORS=$((INTEGRITY_ERRORS + 1))
        else
            verbose "✓ Value match for $from_key"
        fi
    fi
done

if [[ $INTEGRITY_ERRORS -eq 0 ]]; then
    log "Data integrity check passed"
else
    error "$INTEGRITY_ERRORS data integrity errors found"
fi

# Summary
echo "=== Validation Summary ==="
TOTAL_ERRORS=$((MISSING_KEYS + INTEGRITY_ERRORS))

if [[ $TOTAL_ERRORS -eq 0 ]]; then
    log "All validations passed! Configuration split logic is working correctly."
    echo ""
    echo "Output files ready for review:"
    echo "  Static:  $TEMP_STATIC"
    echo "  Dynamic: $TEMP_DYNAMIC"

    if [[ $VERBOSE -eq 1 ]]; then
        echo ""
        echo "Static config preview:"
        head -20 "$TEMP_STATIC" | sed 's/^/  /'
        echo ""
        echo "Dynamic config preview:"
        head -20 "$TEMP_DYNAMIC" | sed 's/^/  /'
    fi

    exit 0
else
    error "Validation failed with $TOTAL_ERRORS errors"
    exit 1
fi
