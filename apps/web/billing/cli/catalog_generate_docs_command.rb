# apps/web/billing/cli/catalog_generate_docs_command.rb
#
# frozen_string_literal: true

require 'yaml'
require_relative 'helpers'
require_relative '../config'

module Onetime
  module CLI
    # Generate markdown documentation from plan catalog YAML
    class BillingCatalogGenerateDocsCommand < Command
      include BillingHelpers

      desc 'Generate plan-definitions.md from billing.yaml'

      option :output, type: :string,
        desc: 'Output file path (default: docs/billing/plan-definitions.md)'

      def call(output: nil, **)
        boot_application!

        catalog_path = Billing::Config.config_path
        output_path  = output || File.join('docs', 'billing', 'plan-definitions.md')

        unless File.exist?(catalog_path)
          puts "❌ Error: Catalog file not found: #{catalog_path}"
          return
        end

        puts "Loading catalog: #{catalog_path}"

        catalog = Billing::Config.safe_load_config

        # Load entitlements from billing.yaml
        entitlements = Billing::Config.load_entitlements
        puts "Loaded #{entitlements.size} entitlements from billing config"

        markdown = generate_markdown(catalog, entitlements)

        File.write(output_path, markdown)

        puts "✅ Documentation generated: #{output_path}"
        puts "   #{markdown.lines.count} lines, #{markdown.bytesize} bytes"
      rescue Psych::SyntaxError => ex
        puts "❌ YAML syntax error: #{ex.message}"
      rescue StandardError => ex
        puts "❌ Error generating docs: #{ex.message}"
        puts ex.backtrace.first(5).join("\n") if OT.debug?
      end

      private

      def generate_markdown(catalog, entitlements)
        parts = []

        parts << generate_header(catalog)
        parts << generate_entitlements_section(entitlements) if entitlements&.any?
        parts << generate_plans_overview_table(catalog)
        parts << generate_plan_details(catalog, entitlements)
        parts << generate_stripe_metadata_section(catalog)
        parts << generate_validation_section

        parts.join("\n\n")
      end

      def generate_entitlements_section(entitlements)
        parts = ['## Entitlement Definitions', '']
        parts << 'Entitlements define features/permissions available in the billing system.'
        parts << 'Loaded from `etc/billing.yaml`.'
        parts << ''

        # Group by category
        categories = entitlements.values.map { |ent| ent['category'] }.uniq.sort

        categories.each do |category|
          ents_in_category = entitlements.select { |_id, ent| ent['category'] == category }
          next if ents_in_category.empty?

          parts << "### #{category.capitalize}"
          parts << ''

          ents_in_category.each do |ent_id, ent_data|
            parts << "- **`#{ent_id}`**: #{ent_data['description']}"
          end

          parts << ''
        end

        parts.join("\n")
      end

      def generate_header(catalog)
        <<~MD
          # Plan Catalog Reference

          **Auto-generated from:** `etc/billing.yaml`
          **Schema Version:** #{catalog['schema_version']}
          **Last Updated:** #{Time.now.strftime('%Y-%m-%d %H:%M UTC')}

          ⚠️ **Do not edit this file directly.** Make changes to `etc/billing.yaml` and regenerate with:
          ```bash
          bin/ots billing catalog generate-docs
          ```

          ## Overview

          This document describes the billing plan structure and entitlements for Onetime Secret. Plan definitions are stored in Stripe product metadata and cached in Redis via `Billing::Plan`.
        MD
      end

      def generate_plans_overview_table(catalog)
        plans = catalog['plans'] || {}

        rows = []
        rows << '## Plans Overview'
        rows << ''
        rows << '| Plan ID | Name | Tier | Tenancy | Region | Display Order | On Plans Page | Legacy |'
        rows << '|---------|------|------|---------|--------|---------------|---------------|--------|'

        plans.each do |plan_id, plan_data|
          show_icon   = plan_data['show_on_plans_page'] ? '✓' : '✗'
          legacy_icon = plan_data['legacy'] ? '⚠️' : ''
          rows << format('| %s | %s | %s | %s | %s | %s | %s | %s |',
            plan_id,
            plan_data['name'],
            plan_data['tier'],
            plan_data['tenancy'],
            plan_data['region'],
            plan_data['display_order'],
            show_icon,
            legacy_icon,
          )
        end

        rows.join("\n")
      end

      def generate_plan_details(catalog, entitlements)
        plans = catalog['plans'] || {}

        sections = ['## Plan Details', '']

        plans.each do |plan_id, plan_data|
          sections << generate_plan_section(plan_id, plan_data, entitlements)
          sections << ''
          sections << '---'
          sections << ''
        end

        sections.join("\n")
      end

      def generate_plan_section(plan_id, plan_data, _entitlements)
        parts = []

        # Header with legacy badge
        legacy_badge = plan_data['legacy'] ? ' ⚠️ **(Legacy)**' : ''
        parts << "### #{plan_data['name']} (`#{plan_id}`)#{legacy_badge}"
        parts << ''
        parts << plan_data['description'] if plan_data['description']
        parts << ''

        # Legacy info
        if plan_data['legacy'] && plan_data['grandfathered_until']
          parts << "**Grandfathered Until:** #{plan_data['grandfathered_until']}"
          parts << ''
        end

        # Metadata
        parts << ('**Tier:** ' + plan_data['tier'])
        parts << ('**Tenancy:** ' + plan_data['tenancy'])
        parts << ('**Region:** ' + plan_data['region'])
        parts << ''

        # Entitlements
        if plan_data['entitlements']&.any?
          parts << '**Entitlements:**'
          plan_data['entitlements'].each do |ent|
            parts << "- `#{ent}`"
          end
          parts << ''
        end

        # Limits table
        if plan_data['limits']&.any?
          parts << '**Limits:**'
          parts << ''
          parts << '| Resource | Limit | Notes |'
          parts << '|----------|-------|-------|'

          plan_data['limits'].each do |resource, value|
            formatted_value = format_limit_value(value)
            notes           = limit_notes(resource, value)
            parts << "| #{resource} | #{formatted_value} | #{notes} |"
          end
          parts << ''
        end

        # Pricing
        if plan_data['prices']&.any?
          parts << '**Pricing:**'
          plan_data['prices'].each do |price|
            amount_dollars = (price['amount'] / 100.0).round(2)
            currency_upper = price['currency'].upcase
            interval_label = price['interval'] == 'month' ? 'Monthly' : 'Annual'

            parts << "- #{interval_label}: $#{amount_dollars} #{currency_upper}"
          end
        elsif plan_id == 'free_v1'
          parts << '**Pricing:** Free'
        end

        parts.join("\n")
      end

      def format_limit_value(value)
        case value
        when -1
          '∞ (unlimited)'
        when nil
          'TBD'
        else
          value.to_s
        end
      end

      def limit_notes(resource, value)
        case resource
        when 'secret_lifetime'
          value ? "#{value / 86_400} days" : ''
        when 'teams'
          value == 0 ? 'No team access' : ''
        when 'members_per_team'
          value == 1 ? 'Individual only' : ''
        else
          ''
        end
      end

      def generate_stripe_metadata_section(catalog)
        schema = catalog['stripe_metadata_schema'] || {}

        parts = ['## Stripe Product Configuration', '']
        parts << 'Each Stripe product must include specific metadata fields to be recognized by the billing system.'
        parts << ''

        if schema['required']
          parts << '### Required Metadata Fields'
          parts << ''
          parts << '```json'
          parts << '{'

          schema['required'].each_with_index do |(key, desc), idx|
            comma = idx < schema['required'].size - 1 ? ',' : ''
            parts << "  \"#{key}\": \"#{desc}\"#{comma}"
          end

          parts << '}'
          parts << '```'
          parts << ''
        end

        if schema['optional']
          parts << '### Optional Metadata Fields'
          parts << ''
          parts << '```json'
          parts << '{'

          schema['optional'].each_with_index do |(key, desc), idx|
            comma = idx < schema['optional'].size - 1 ? ',' : ''
            parts << "  \"#{key}\": \"#{desc}\"#{comma}"
          end

          parts << '}'
          parts << '```'
        end

        parts.join("\n")
      end

      def generate_validation_section
        <<~MD
          ## Validation and Sync

          ### Validate Catalog Structure

          Validate YAML structure and compare with Stripe:

          ```bash
          bin/ots billing catalog validate
          bin/ots billing catalog validate --catalog-only  # Skip Stripe comparison
          bin/ots billing catalog validate --strict        # Fail on warnings
          ```

          ### Sync Plans from Stripe

          After configuring products in Stripe, sync to local Redis cache:

          ```bash
          bin/ots billing sync
          bin/ots billing sync --clear  # Clear cache first
          ```

          Only products with all required metadata fields, at least one recurring price, and `app: "onetimesecret"` will be synced.

          ### View Cached Plans

          ```bash
          bin/ots billing plans
          ```

          ## Setup Workflow

          1. **Edit catalog:** Modify `etc/billing.yaml`
          2. **Validate:** `bin/ots billing catalog validate --catalog-only`
          3. **Create/update in Stripe:** `./scripts/setup_stripe_plans.sh --update`
          4. **Verify in Stripe:** Check Stripe Dashboard
          5. **Sync to cache:** `bin/ots billing sync`
          6. **Update docs:** `bin/ots billing catalog generate-docs`
          7. **Commit:** Commit both YAML and generated docs
        MD
      end
    end
  end
end

Onetime::CLI.register 'billing catalog generate-docs', Onetime::CLI::BillingCatalogGenerateDocsCommand
