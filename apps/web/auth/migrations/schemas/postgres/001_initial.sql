-- ================================================================
-- Rodauth PostgreSQL Essential Schema with MFA
-- Authentication and Account Management System
-- Features: base, json, login, logout, create_account, close_account,
-- login_password_requirements_base, change_password, reset_password,
-- remember, verify_account, lockout, active_sessions, otp, recovery_codes
-- ================================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS citext;

-- ================================================================
-- CORE TABLES (Required for all Rodauth configurations)
-- ================================================================

-- Account status lookup table
CREATE TABLE account_statuses (
    id INTEGER PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE
);

-- Insert default status values
INSERT INTO account_statuses (id, name) VALUES
    (1, 'Unverified'),
    (2, 'Verified'),
    (3, 'Closed');

-- Main accounts table
CREATE TABLE accounts (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    external_id VARCHAR(64) UNIQUE,
    email CITEXT NOT NULL,
    status_id INTEGER NOT NULL DEFAULT 1,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_ip INET,
    last_login_at TIMESTAMPTZ,

    -- Email validation constraint
    CONSTRAINT valid_email CHECK (email ~ '^[^,;@ \r\n]+@[^,@; \r\n]+\.[^,@; \r\n]+$'),
    FOREIGN KEY (status_id) REFERENCES account_statuses(id)
);

-- Unique email constraint for active accounts only (partial index)
CREATE UNIQUE INDEX accounts_email_unique ON accounts(email)
WHERE status_id IN (1, 2);

-- Performance indexes
CREATE INDEX accounts_status_id_idx ON accounts(status_id);
CREATE INDEX accounts_created_at_idx ON accounts(created_at);
CREATE INDEX accounts_last_login_at_idx ON accounts(last_login_at);
CREATE INDEX accounts_last_login_ip_idx ON accounts(last_login_ip);

-- ================================================================
-- PASSWORD MANAGEMENT (Separate table for security)
-- ================================================================

-- Password hashes (stored separately for security)
CREATE TABLE account_password_hashes (
    id BIGINT PRIMARY KEY,
    password_hash VARCHAR NOT NULL,
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- ACCOUNT VERIFICATION
-- ================================================================

-- Email verification keys
CREATE TABLE account_verification_keys (
    id BIGINT PRIMARY KEY,
    key VARCHAR NOT NULL UNIQUE,
    requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    email_last_sent TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- PASSWORD RESET FUNCTIONALITY
-- ================================================================

-- Password reset keys
CREATE TABLE account_password_reset_keys (
    id BIGINT PRIMARY KEY,
    key VARCHAR NOT NULL UNIQUE,
    deadline TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '1 day'),
    email_last_sent TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- BRUTE FORCE PROTECTION
-- ================================================================

-- Login failure tracking
CREATE TABLE account_login_failures (
    id BIGINT PRIMARY KEY,
    number INTEGER NOT NULL DEFAULT 1,
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Account lockout management
CREATE TABLE account_lockouts (
    id BIGINT PRIMARY KEY,
    key VARCHAR NOT NULL UNIQUE,
    deadline TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '1 day'),
    email_last_sent TIMESTAMPTZ DEFAULT NOW(),
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- REMEMBER ME FUNCTIONALITY
-- ================================================================

-- Remember me tokens
CREATE TABLE account_remember_keys (
    id BIGINT PRIMARY KEY,
    key VARCHAR NOT NULL UNIQUE,
    deadline TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '21 days'),
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- SESSION MANAGEMENT
-- ================================================================

-- Active session tracking
CREATE TABLE account_active_session_keys (
    account_id BIGINT NOT NULL,
    session_id VARCHAR NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_use TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (account_id, session_id),
    FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Session performance index
CREATE INDEX account_active_session_keys_last_use_idx ON account_active_session_keys(last_use);
CREATE INDEX account_active_session_keys_account_id_idx ON account_active_session_keys(account_id);

-- ================================================================
-- MULTI-FACTOR AUTHENTICATION (OTP)
-- ================================================================

-- OTP (TOTP) secret keys for Google Authenticator, etc.
CREATE TABLE account_otp_keys (
    id BIGINT PRIMARY KEY,
    key VARCHAR NOT NULL,
    num_failures INTEGER NOT NULL DEFAULT 0,
    last_use TIMESTAMPTZ DEFAULT NOW(),
    FOREIGN KEY (id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ================================================================
-- RECOVERY CODES (MFA Backup)
-- ================================================================

-- Recovery codes for MFA bypass
CREATE TABLE account_recovery_codes (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    account_id BIGINT NOT NULL,
    code VARCHAR NOT NULL UNIQUE,
    used_at TIMESTAMPTZ,
    FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Indexes for efficient lookup
CREATE INDEX account_recovery_codes_account_id_idx ON account_recovery_codes(account_id);
CREATE INDEX account_recovery_codes_code_idx ON account_recovery_codes(code);
CREATE INDEX account_recovery_codes_unused_idx ON account_recovery_codes(account_id) WHERE used_at IS NULL;

-- ================================================================
-- AUDIT AND SECURITY LOGGING
-- ================================================================

-- Authentication audit log
CREATE TABLE account_authentication_audit_logs (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    account_id BIGINT NOT NULL,
    at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    message TEXT NOT NULL,
    metadata JSONB, -- JSON data with indexing support
    FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Audit log indexes
CREATE INDEX account_authentication_audit_logs_account_at_idx ON account_authentication_audit_logs(account_id, at);
CREATE INDEX account_authentication_audit_logs_at_idx ON account_authentication_audit_logs(at);
CREATE INDEX account_authentication_audit_logs_metadata_idx ON account_authentication_audit_logs USING GIN(metadata);

-- ================================================================
-- DATABASE FUNCTIONS FOR ENHANCED SECURITY
-- ================================================================

-- Function to get password salt (for database-level security)
CREATE OR REPLACE FUNCTION rodauth_get_salt(p_account_id BIGINT)
RETURNS TEXT AS $$
DECLARE
    salt TEXT;
BEGIN
    SELECT SUBSTRING(password_hash FROM 1 FOR 29) INTO salt
    FROM account_password_hashes
    WHERE account_id = p_account_id;
    RETURN salt;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to validate password hash (for database-level security)
CREATE OR REPLACE FUNCTION rodauth_valid_password_hash(p_account_id BIGINT, hash TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    valid BOOLEAN := FALSE;
BEGIN
    SELECT password_hash = hash INTO valid
    FROM account_password_hashes
    WHERE account_id = p_account_id;
    RETURN COALESCE(valid, FALSE);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ================================================================
-- TRIGGERS FOR DATA MAINTENANCE
-- ================================================================

-- Update account updated_at timestamp
CREATE OR REPLACE FUNCTION update_accounts_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_accounts_updated_at
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION update_accounts_updated_at();

-- Clean up expired tokens function
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS VOID AS $$
BEGIN
    -- Clean up expired password reset keys
    DELETE FROM account_password_reset_keys WHERE deadline < NOW();

    -- Clean up expired remember keys
    DELETE FROM account_remember_keys WHERE deadline < NOW();

    -- Clean up expired lockouts
    DELETE FROM account_lockouts WHERE deadline < NOW();

    -- Log cleanup action
    RAISE NOTICE 'Cleaned up expired tokens at %', NOW();
END;
$$ LANGUAGE plpgsql;

-- ================================================================
-- VIEWS FOR COMMON QUERIES
-- ================================================================

-- Account summary with status
CREATE VIEW accounts_with_status AS
SELECT
    a.id,
    a.external_id,
    a.email,
    s.name as status_name,
    a.status_id,
    a.created_at,
    a.updated_at,
    a.last_login_at,
    a.last_login_ip,
    CASE WHEN ph.id IS NOT NULL THEN TRUE ELSE FALSE END as has_password,
    CASE WHEN otpk.id IS NOT NULL THEN TRUE ELSE FALSE END as has_otp
FROM accounts a
JOIN account_statuses s ON a.status_id = s.id
LEFT JOIN account_password_hashes ph ON a.id = ph.id
LEFT JOIN account_otp_keys otpk ON a.id = otpk.id;

-- Active sessions with account info
CREATE VIEW active_sessions_with_accounts AS
SELECT
    ask.account_id,
    ask.session_id,
    ask.created_at,
    ask.last_use,
    a.external_id,
    a.email,
    CASE
        WHEN ask.last_use + INTERVAL '30 days' > NOW() THEN 'Active'
        ELSE 'Expired'
    END as session_status,
    EXTRACT(EPOCH FROM (NOW() - ask.last_use))/3600 as hours_since_use
FROM account_active_session_keys ask
JOIN accounts a ON ask.account_id = a.id;

-- ================================================================
-- SECURITY POLICIES (Row Level Security)
-- ================================================================

-- Enable RLS on sensitive tables
ALTER TABLE account_password_hashes ENABLE ROW LEVEL SECURITY;
ALTER TABLE account_otp_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE account_recovery_codes ENABLE ROW LEVEL SECURITY;

-- Policies will be defined based on application user roles
-- Example: Only password functions can access password hashes
-- CREATE POLICY password_access ON account_password_hashes
--   FOR ALL TO password_user USING (true);

-- ================================================================
-- MAINTENANCE QUERIES (Execute manually as needed)
-- ================================================================

/*
-- Manual cleanup of old data
SELECT cleanup_expired_tokens();

-- Clean up old audit logs (keep last 90 days)
DELETE FROM account_authentication_audit_logs
WHERE at < NOW() - INTERVAL '90 days';

-- Clean up old inactive sessions (30+ days)
DELETE FROM account_active_session_keys
WHERE last_use < NOW() - INTERVAL '30 days';

-- Update session last_use timestamp (call from application)
UPDATE account_active_session_keys
SET last_use = NOW()
WHERE account_id = $1 AND session_id = $2;

-- Check account security status
SELECT
    a.id,
    a.email,
    s.name as status,
    CASE WHEN ph.id IS NOT NULL THEN 'Yes' ELSE 'No' END as has_password,
    CASE WHEN otpk.id IS NOT NULL THEN 'Yes' ELSE 'No' END as has_otp,
    COALESCE(lf.number, 0) as failed_attempts,
    COUNT(ask.session_id) as active_sessions,
    COUNT(rc.id) FILTER (WHERE rc.used_at IS NULL) as unused_recovery_codes
FROM accounts a
JOIN account_statuses s ON a.status_id = s.id
LEFT JOIN account_password_hashes ph ON a.id = ph.id
LEFT JOIN account_otp_keys otpk ON a.id = otpk.id
LEFT JOIN account_login_failures lf ON a.id = lf.id
LEFT JOIN account_active_session_keys ask ON a.id = ask.account_id
LEFT JOIN account_recovery_codes rc ON a.id = rc.account_id
WHERE a.status_id IN (1, 2)
GROUP BY a.id, a.email, s.name, ph.id, otpk.id, lf.number;

-- Performance analysis
SELECT schemaname, tablename, attname, n_distinct, correlation
FROM pg_stats
WHERE schemaname = 'public'
AND tablename LIKE 'account%'
ORDER BY tablename, attname;

-- Example: Check if email exists
-- SELECT COUNT(*) FROM accounts WHERE email = 'user@example.com';

-- Example: Get account with status
-- SELECT * FROM accounts_with_status WHERE email = 'user@example.com';

-- Example: View active sessions for account
-- SELECT * FROM active_sessions_with_accounts
-- WHERE account_id = 1 AND session_status = 'Active';
*/
