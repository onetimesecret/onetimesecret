# tests/unit/ruby/rspec/onetime/app/web/window_state_schema_spec.rb

require_relative '../../../spec_helper'

RSpec.describe 'Window State Schema Validation' do
  let(:config) { OT.conf }

  # Mock UIContext data structure that would be generated by the Ruby backend
  # This simulates the data structure that gets serialized to window.onetime
  let(:mock_ui_context) do
    {
      # Core Authentication & User Data
      authenticated: false,
      custid: nil,
      cust: {
        identifier: 'anon',
        custid: 'anon',
        email: nil,
        role: 'customer',
        verified: nil,
        last_login: nil,
        locale: '',
        updated: nil,
        created: nil,
        stripe_customer_id: nil,
        stripe_subscription_id: nil,
        stripe_checkout_email: nil,
        plan: {
          planid: nil,
          source: 'parts_unknown'
        },
        secrets_created: '0',
        secrets_burned: '0',
        secrets_shared: '0',
        emails_sent: '0',
        active: false
      },
      email: nil,
      customer_since: nil,

      # Configuration Sections
      authentication: {
        enabled: true,
        signin: true,
        signup: true,
        autoverify: false
      },
      d9s_enabled: true,
      diagnostics: {
        sentry: {
          dsn: 'https://example@sentry.io/123',
          sampleRate: nil,
          maxBreadcrumbs: nil,
          logErrors: true,
          trackComponents: true
        }
      },
      domains: {
        enabled: true,
        default: nil
      },
      domains_enabled: true,
      frontend_development: true,
      frontend_host: 'http://localhost:5173',
      incoming_recipient: nil,
      plans_enabled: true,
      regions: {
        enabled: true,
        current_jurisdiction: 'EU'
      },
      regions_enabled: true,
      secret_options: {
        default_ttl: 604800.0,
        ttl_options: [60, 300, 1800, 3600, 14400, 43200, 86400, 259200, 604800, 1209600, 2592000]
      },
      site_host: 'dev.onetime.dev',
      support_host: nil,
      ui: {
        enabled: true,
        header: {
          enabled: true,
          branding: {
            logo: {
              url: 'DefaultLogo',
              alt: 'Share a Secret One-Time',
              href: '/'
            },
            site_name: 'One-Time Secret'
          },
          navigation: {
            enabled: true
          }
        },
        footer_links: {
          enabled: false,
          groups: []
        }
      },

      # Domain & Branding
      canonical_domain: 'dev.onetime.dev',
      custom_domains: nil,
      display_domain: 'dev.onetime.dev',
      domain_branding: nil,
      domain_id: nil,
      domain_locale: nil,
      domain_logo: nil,
      domain_strategy: 'canonical',

      # Internationalization
      locale: 'en',
      default_locale: 'en',
      fallback_locale: {
        'fr-CA' => ['fr_CA', 'fr_FR', 'en'],
        'fr' => ['fr_FR', 'fr_CA', 'en'],
        'de-AT' => ['de_AT', 'de', 'en'],
        'de' => ['de', 'de_AT', 'en'],
        'it' => ['it_IT', 'en'],
        'pt' => ['pt_BR', 'en'],
        'default' => ['en']
      },
      supported_locales: ['bg', 'da_DK', 'de', 'de_AT', 'el_GR', 'en', 'es', 'fr_CA', 'fr_FR', 'it_IT', 'ja', 'ko', 'mi_NZ', 'nl', 'tr', 'uk', 'pl', 'pt_BR', 'sv_SE'],
      i18n_enabled: true,

      # System Information
      ot_version: '0.22.3',
      ot_version_long: '0.22.3 (e16fe4ac)',
      ruby_version: 'ruby-341',
      shrimp: 'test-csrf-token',
      nonce: 'test-nonce-123',

      # Business Logic
      plan: {
        identifier: 'anonymous',
        planid: 'anonymous',
        price: 0,
        discount: 0,
        options: {
          ttl: 604800.0,
          size: 100000,
          api: false,
          name: 'Anonymous'
        }
      },
      is_paid: false,
      default_planid: 'basic',
      available_plans: {},

      # Messaging & UI State
      messages: [],
      global_banner: nil
    }
  end

  describe 'Top-level key validation' do
    let(:required_keys) do
      %w[
        authenticated custid cust email customer_since
        authentication d9s_enabled diagnostics domains domains_enabled
        frontend_development frontend_host incoming_recipient plans_enabled
        regions regions_enabled secret_options site_host support_host ui
        canonical_domain custom_domains display_domain domain_branding
        domain_id domain_locale domain_logo domain_strategy
        locale default_locale fallback_locale supported_locales i18n_enabled
        ot_version ot_version_long ruby_version shrimp nonce
        plan is_paid default_planid available_plans
        messages global_banner
      ]
    end

    it 'contains all required top-level keys' do
      aggregate_failures 'checking required keys' do
        required_keys.each do |key|
          expect(mock_ui_context).to have_key(key.to_sym), "Expected key '#{key}' to be present"
        end
      end
    end

    it 'has correct data types for core fields' do
      aggregate_failures 'checking data types' do
        # Core user data
        expect(mock_ui_context[:authenticated]).to be(true).or be(false)
        expect(mock_ui_context[:custid]).to be_nil.or(be_a(String))
        expect(mock_ui_context[:cust]).to be_a(Hash)
        expect(mock_ui_context[:email]).to be_nil.or(be_a(String))

        # Configuration sections
        expect(mock_ui_context[:authentication]).to be_a(Hash)
        expect(mock_ui_context[:secret_options]).to be_a(Hash)
        expect(mock_ui_context[:ui]).to be_a(Hash)
        expect(mock_ui_context[:regions]).to be_a(Hash)
        expect(mock_ui_context[:diagnostics]).to be_a(Hash)

        # System information
        expect(mock_ui_context[:ot_version]).to be_a(String)
        expect(mock_ui_context[:ruby_version]).to be_a(String)
        expect(mock_ui_context[:shrimp]).to be_a(String)
        expect(mock_ui_context[:nonce]).to be_a(String)

        # Feature flags
        expect(mock_ui_context[:d9s_enabled]).to be(true).or be(false)
        expect(mock_ui_context[:domains_enabled]).to be(true).or be(false)
        expect(mock_ui_context[:regions_enabled]).to be(true).or be(false)
        expect(mock_ui_context[:plans_enabled]).to be(true).or be(false)
        expect(mock_ui_context[:i18n_enabled]).to be(true).or be(false)

        # Internationalization
        expect(mock_ui_context[:locale]).to be_a(String)
        expect(mock_ui_context[:supported_locales]).to be_a(Array)
        expect(mock_ui_context[:fallback_locale]).to be_a(Hash)

        # Business logic
        expect(mock_ui_context[:plan]).to be_a(Hash)
        expect(mock_ui_context[:is_paid]).to be(true).or be(false)
        expect(mock_ui_context[:available_plans]).to be_a(Hash)

        # Arrays
        expect(mock_ui_context[:messages]).to be_a(Array)
      end
    end
  end

  describe 'Nested object validation' do
    describe 'customer object' do
      let(:cust) { mock_ui_context[:cust] }

      it 'has required customer fields' do
        required_customer_fields = %w[identifier custid email role verified last_login locale updated created stripe_customer_id stripe_subscription_id stripe_checkout_email plan secrets_created secrets_burned secrets_shared emails_sent active]

        aggregate_failures 'checking customer fields' do
          required_customer_fields.each do |field|
            expect(cust).to have_key(field.to_sym), "Expected customer to have field '#{field}'"
          end
        end
      end

      it 'has valid customer plan structure' do
        plan = cust[:plan]
        expect(plan).to be_a(Hash)
        expect(plan).to have_key(:planid)
        expect(plan).to have_key(:source)
      end
    end

    describe 'authentication object' do
      let(:auth) { mock_ui_context[:authentication] }

      it 'has required authentication fields' do
        required_auth_fields = %w[enabled signin signup autoverify]

        aggregate_failures 'checking authentication fields' do
          required_auth_fields.each do |field|
            expect(auth).to have_key(field.to_sym), "Expected authentication to have field '#{field}'"
          end
        end
      end

      it 'has boolean values for authentication flags' do
        aggregate_failures 'checking authentication flag types' do
          expect(auth[:enabled]).to be(true).or be(false)
          expect(auth[:signin]).to be(true).or be(false)
          expect(auth[:signup]).to be(true).or be(false)
          expect(auth[:autoverify]).to be(true).or be(false)
        end
      end
    end

    describe 'secret_options object' do
      let(:secret_opts) { mock_ui_context[:secret_options] }

      it 'has required secret options fields' do
        expect(secret_opts).to have_key(:default_ttl)
        expect(secret_opts).to have_key(:ttl_options)
      end

      it 'has valid secret options data types' do
        expect(secret_opts[:default_ttl]).to be_a(Numeric)
        expect(secret_opts[:ttl_options]).to be_a(Array)
        expect(secret_opts[:ttl_options]).to all(be_a(Numeric))
      end
    end

    describe 'ui object' do
      let(:ui) { mock_ui_context[:ui] }

      it 'has required ui fields' do
        expect(ui).to have_key(:enabled)
        expect(ui[:enabled]).to be(true).or be(false)
      end

      it 'has valid header structure when present' do
        if ui[:header]
          expect(ui[:header]).to be_a(Hash)
          expect(ui[:header]).to have_key(:enabled)

          if ui[:header][:branding]
            expect(ui[:header][:branding]).to be_a(Hash)
            expect(ui[:header][:branding]).to have_key(:logo) if ui[:header][:branding][:logo]
          end
        end
      end
    end

    describe 'diagnostics object' do
      let(:diagnostics) { mock_ui_context[:diagnostics] }

      it 'has sentry configuration' do
        expect(diagnostics).to have_key(:sentry)

        sentry = diagnostics[:sentry]
        expect(sentry).to be_a(Hash)
        expect(sentry).to have_key(:dsn)
        expect(sentry).to have_key(:logErrors)
        expect(sentry).to have_key(:trackComponents)
      end
    end
  end

  describe 'Security and sanitization' do
    it 'does not expose sensitive configuration data' do
      # Ensure sensitive data is not present in the window state
      sensitive_keys = %w[database_password redis_password stripe_secret_key mail_password]

      aggregate_failures 'checking for sensitive data' do
        sensitive_keys.each do |key|
          expect(mock_ui_context).not_to have_key(key.to_sym), "Sensitive key '#{key}' should not be exposed to frontend"
        end
      end
    end

    it 'has valid CSRF token format' do
      expect(mock_ui_context[:shrimp]).to be_a(String)
      expect(mock_ui_context[:shrimp]).not_to be_empty
    end

    it 'has valid nonce format' do
      expect(mock_ui_context[:nonce]).to be_a(String)
      expect(mock_ui_context[:nonce]).not_to be_empty
    end
  end

  describe 'Internationalization validation' do
    it 'has valid locale configuration' do
      expect(mock_ui_context[:locale]).to be_a(String)
      expect(mock_ui_context[:default_locale]).to be_a(String)
      expect(mock_ui_context[:supported_locales]).to be_a(Array)
      expect(mock_ui_context[:supported_locales]).to include(mock_ui_context[:default_locale])
    end

    it 'has valid fallback locale structure' do
      fallback = mock_ui_context[:fallback_locale]
      expect(fallback).to be_a(Hash)
      expect(fallback).to have_key('default')
      expect(fallback['default']).to be_a(Array)
    end
  end

  describe 'Domain and branding validation' do
    it 'has consistent domain information' do
      expect(mock_ui_context[:canonical_domain]).to be_a(String)
      expect(mock_ui_context[:display_domain]).to be_a(String)
      expect(mock_ui_context[:domain_strategy]).to be_a(String)
      expect(mock_ui_context[:domain_strategy]).to match(/^(canonical|subdomain|custom|invalid)$/)
    end
  end

  describe 'Plan and business logic validation' do
    it 'has valid plan structure' do
      plan = mock_ui_context[:plan]
      expect(plan).to be_a(Hash)
      expect(plan).to have_key(:identifier)
      expect(plan).to have_key(:planid)
      expect(plan).to have_key(:price)
      expect(plan).to have_key(:options)
    end

    it 'has consistent payment status' do
      expect(mock_ui_context[:is_paid]).to be(true).or be(false)
      expect(mock_ui_context[:available_plans]).to be_a(Hash)
    end
  end
end
